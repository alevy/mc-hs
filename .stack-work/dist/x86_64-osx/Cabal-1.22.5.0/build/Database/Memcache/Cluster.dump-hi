
==================== FINAL INTERFACE ====================
2016-02-25 11:05:45.254897 UTC

interface memca_3Z8qUpsEDiC53dYw3oq6HZ:Database.Memcache.Cluster 7103
  interface hash: 816444e0c1fe2ba6d0b90b91768e2cd4
  ABI hash: 69d36a3983aee9ce8deacc84cec5a09b
  export-list hash: b6eacf84f8e43a614e1d0147693ef59a
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: d2441901af32bd4e2f764a2d98787fe1
  sig of: Nothing
  used TH splices: False
  where
exports:
  Database.Memcache.Cluster.allOp
  Database.Memcache.Cluster.anyOp
  Database.Memcache.Cluster.defaultOptions
  Database.Memcache.Cluster.defaultServerSpec
  Database.Memcache.Cluster.keyedOp
  Database.Memcache.Cluster.newCluster
  Database.Memcache.Cluster.Cluster
  Database.Memcache.Cluster.Options{Database.Memcache.Cluster.Options Database.Memcache.Cluster.optsCmdFailure Database.Memcache.Cluster.optsServerFailure Database.Memcache.Cluster.optsServerRetries}
  Database.Memcache.Cluster.ServerSpec{Database.Memcache.Cluster.ServerSpec Database.Memcache.Cluster.ssAuth Database.Memcache.Cluster.ssHost Database.Memcache.Cluster.ssPort}
module dependencies: Database.Memcache.Errors
                     Database.Memcache.SASL Database.Memcache.Server
                     Database.Memcache.Types Database.Memcache.Wire
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0 binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi
                      blaze-builder-0.4.0.1@blaze_GoSGMrJXTmeEBoF3sgxwrM
                      bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6
                      containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      hashable-1.2.4.0@hasha_8GjadD03dR57AKCJdr90LD integer-gmp-1.0.0.0
                      monad-control-1.0.0.5@monad_0V0Z5ArSaI68lPP0A0bpaP
                      network-2.6.2.1@netwo_A6pE0dLgMEk2GtUa1JtTJQ
                      primitive-0.6.1.0@primi_EphY2c7CCxSCBKjAN0YTR3
                      resource-pool-0.2.3.2@resou_IPeOzEJlakZ6oei4wPpERj
                      stm-2.4.4.1@stm_EyxFXFfnfY05IrjGaqCxeD
                      text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI
                      time-1.5.0.1@time_FTheb6LSxyX1UABIbBXRfn
                      transformers-base-0.4.4@trans_74WedXVmfaHHDJItmBRTVp
                      transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF
                      vector-0.11.0.0@vecto_LmZ3LQW4ivu8MsQuVgukln
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString.Builder
         hashable-1.2.4.0@hasha_8GjadD03dR57AKCJdr90LD:Data.Hashable.Generic
         network-2.6.2.1@netwo_A6pE0dLgMEk2GtUa1JtTJQ:Network.Socket
         network-2.6.2.1@netwo_A6pE0dLgMEk2GtUa1JtTJQ:Network.Socket.Types
         stm-2.4.4.1@stm_EyxFXFfnfY05IrjGaqCxeD:Control.Monad.STM
         text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI:Data.Text
         text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI:Data.Text.Lazy
         text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI:Data.Text.Show
         transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.Error
         vector-0.11.0.0@vecto_LmZ3LQW4ivu8MsQuVgukln:Data.Vector.Fusion.Bundle
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.IntMap.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.IntSet.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Sequence
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
                         monad-control-1.0.0.5@monad_0V0Z5ArSaI68lPP0A0bpaP:Control.Monad.Trans.Control
                         primitive-0.6.1.0@primi_EphY2c7CCxSCBKjAN0YTR3:Control.Monad.Primitive
                         text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI:Data.Text
                         text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI:Data.Text.Lazy
                         vector-0.11.0.0@vecto_LmZ3LQW4ivu8MsQuVgukln:Data.Vector
import  -/  base-4.8.2.0:Control.Exception e9090e246fba030faecf7b81b3e8e320
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Traversable 7576318f4ef8587ad947f87012b65abf
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Exception 18c46fe9c5c0c3a120035f264ef32d41
import  -/  base-4.8.2.0:GHC.IO bb5b81adcea33b14bd4abe16d7dde45f
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  hashable-1.2.4.0@hasha_8GjadD03dR57AKCJdr90LD:Data.Hashable 244dab13cdbae2b410cb0a7483f1e9a9
import  -/  hashable-1.2.4.0@hasha_8GjadD03dR57AKCJdr90LD:Data.Hashable.Class 7c18f94abf1ad2af4fd9379b4f2e951a
import  -/  Database.Memcache.Errors f8f7d6f9d99620e8545ec26851698f07
  exports: a3cc4d4a1d68c42bd6d48dd70317f453
  MemErrStoreFailed c311e101b207583c079539987663b425
  MemErrUnknownCmd 4c055e4ea255d408a8ddd6ebe4982c50
  MemcacheError b7291049f3eecbbd1edd21fd38d153d3
import  -/  Database.Memcache.Server 7935f876b3050e69916f6708b334cea7
  exports: 4b4f03728680b2d70aa3fff298403484
  Server 0e49d261e0c691d9caf4b6f494d266da
  newServer 17ce5f3cc27f7615525b26d7541a07d4
  sid f990adb067c6fae8ebefb59476c64f15
import  -/  Database.Memcache.Types 1ca9931bda88d72b9d7d6f6ee335bcb6
  exports: b2f7697915662eeadb8e65de002e666b
  Authentication 8ea464ac72c68def1a36ff30f351146e
  Key b20ddb86e07e28f2bf61f4be3964ff74
  NoAuth 00a22d74bae31b8e51e3c522680047a8
import  -/  network-2.6.2.1@netwo_A6pE0dLgMEk2GtUa1JtTJQ:Network.Socket 1c584aab086538b6f7ab7390a01794f4
import  -/  network-2.6.2.1@netwo_A6pE0dLgMEk2GtUa1JtTJQ:Network.Socket.Types c793d129fc346c1acee134cf761972a9
import  -/  vector-0.11.0.0@vecto_LmZ3LQW4ivu8MsQuVgukln:Data.Vector a9f7b451dffdbb06f50d91cda8c049eb
4dfe320a13af7a30ce05d8b404499ba3
  $fEqFailureMode ::
    GHC.Classes.Eq Database.Memcache.Cluster.FailureMode
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Cluster.FailureMode
                  Database.Memcache.Cluster.$fEqFailureMode_$c==
                  Database.Memcache.Cluster.$fEqFailureMode_$c/= -}
4dfe320a13af7a30ce05d8b404499ba3
  $fEqFailureMode_$c/= ::
    Database.Memcache.Cluster.FailureMode
    -> Database.Memcache.Cluster.FailureMode -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: Database.Memcache.Cluster.FailureMode
                   b :: Database.Memcache.Cluster.FailureMode ->
                 case a1 of wild {
                   Database.Memcache.Cluster.FailSilent
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Database.Memcache.Cluster.FailSilent -> GHC.Types.False }
                   Database.Memcache.Cluster.FailToBackup
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Database.Memcache.Cluster.FailToBackup -> GHC.Types.False }
                   Database.Memcache.Cluster.FailToError
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Database.Memcache.Cluster.FailToError -> GHC.Types.False } }) -}
4dfe320a13af7a30ce05d8b404499ba3
  $fEqFailureMode_$c== ::
    Database.Memcache.Cluster.FailureMode
    -> Database.Memcache.Cluster.FailureMode -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Database.Memcache.Cluster.FailureMode
                   ds1 :: Database.Memcache.Cluster.FailureMode ->
                 case ds of wild {
                   Database.Memcache.Cluster.FailSilent
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Database.Memcache.Cluster.FailSilent -> GHC.Types.True }
                   Database.Memcache.Cluster.FailToBackup
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Database.Memcache.Cluster.FailToBackup -> GHC.Types.True }
                   Database.Memcache.Cluster.FailToError
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Database.Memcache.Cluster.FailToError -> GHC.Types.True } }) -}
81936693186238b83f78cd265848a1d7
  $fShowCluster :: GHC.Show.Show Database.Memcache.Cluster.Cluster
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Cluster.Cluster
                  Database.Memcache.Cluster.$fShowCluster_$cshowsPrec
                  Database.Memcache.Cluster.$fShowCluster_$cshow
                  Database.Memcache.Cluster.$fShowCluster_$cshowList -}
81936693186238b83f78cd265848a1d7
  $fShowCluster1 ::
    Database.Memcache.Cluster.Cluster -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Database.Memcache.Cluster.Cluster ->
                 case w of ww { Database.Memcache.Cluster.Cluster ww1 ww2 ww3 ww4 ->
                 Database.Memcache.Cluster.$w$cshowsPrec 0 ww1 ww2 ww3 ww4 }) -}
81936693186238b83f78cd265848a1d7
  $fShowCluster_$cshow ::
    Database.Memcache.Cluster.Cluster -> GHC.Base.String
  {- Arity: 1, Strictness: <S(LSSL),1*U(1*U(U,U,U),U,U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Database.Memcache.Cluster.Cluster ->
                 Database.Memcache.Cluster.$fShowCluster_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
81936693186238b83f78cd265848a1d7
  $fShowCluster_$cshowList ::
    [Database.Memcache.Cluster.Cluster] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Database.Memcache.Cluster.Cluster
                   Database.Memcache.Cluster.$fShowCluster1) -}
81936693186238b83f78cd265848a1d7
  $fShowCluster_$cshowsPrec ::
    GHC.Types.Int
    -> Database.Memcache.Cluster.Cluster -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S(LSSL),1*U(1*U(U,U,U),U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Database.Memcache.Cluster.Cluster ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Database.Memcache.Cluster.Cluster ww3 ww4 ww5 ww6 ->
                 Database.Memcache.Cluster.$w$cshowsPrec ww1 ww3 ww4 ww5 ww6 } }) -}
4dfe320a13af7a30ce05d8b404499ba3
  $fShowFailureMode ::
    GHC.Show.Show Database.Memcache.Cluster.FailureMode
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Cluster.FailureMode
                  Database.Memcache.Cluster.$fShowFailureMode_$cshowsPrec
                  Database.Memcache.Cluster.$fShowFailureMode_$cshow
                  Database.Memcache.Cluster.$fShowFailureMode_$cshowList -}
9e8a8a95f2926609adde75210b7680f4
  $fShowFailureMode1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FailToError"#) -}
b6e3a639ca6a84bfaf98ad4266872662
  $fShowFailureMode2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FailToBackup"#) -}
26e9925d84fc9a7a7238695336e10635
  $fShowFailureMode3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FailSilent"#) -}
4dfe320a13af7a30ce05d8b404499ba3
  $fShowFailureMode_$cshow ::
    Database.Memcache.Cluster.FailureMode -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Database.Memcache.Cluster.FailureMode ->
                 case x of wild {
                   Database.Memcache.Cluster.FailSilent
                   -> Database.Memcache.Cluster.$fShowFailureMode3
                   Database.Memcache.Cluster.FailToBackup
                   -> Database.Memcache.Cluster.$fShowFailureMode2
                   Database.Memcache.Cluster.FailToError
                   -> Database.Memcache.Cluster.$fShowFailureMode1 }) -}
4dfe320a13af7a30ce05d8b404499ba3
  $fShowFailureMode_$cshowList ::
    [Database.Memcache.Cluster.FailureMode] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Database.Memcache.Cluster.FailureMode
                   Database.Memcache.Cluster.$w$cshowsPrec1) -}
4dfe320a13af7a30ce05d8b404499ba3
  $fShowFailureMode_$cshowsPrec ::
    GHC.Types.Int
    -> Database.Memcache.Cluster.FailureMode -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: Database.Memcache.Cluster.FailureMode
                   w2 :: GHC.Base.String ->
                 Database.Memcache.Cluster.$w$cshowsPrec1 w1 w2) -}
f866570e94bf6f434f9f2ffe7bc8c22e
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> Data.Vector.Vector Database.Memcache.Server.Server
    -> Database.Memcache.Cluster.FailureMode
    -> Database.Memcache.Cluster.FailureMode
    -> GHC.Prim.Int#
    -> GHC.Show.ShowS
  {- Arity: 5, Strictness: <L,U><L,1*U(U,U,U)><S,U><S,U><L,U>,
     Inline: [0] -}
4dfe320a13af7a30ce05d8b404499ba3
  $w$cshowsPrec1 ::
    Database.Memcache.Cluster.FailureMode
    -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: Database.Memcache.Cluster.FailureMode
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   Database.Memcache.Cluster.FailSilent
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Database.Memcache.Cluster.$fShowFailureMode3
                        w1
                   Database.Memcache.Cluster.FailToBackup
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Database.Memcache.Cluster.$fShowFailureMode2
                        w1
                   Database.Memcache.Cluster.FailToError
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Database.Memcache.Cluster.$fShowFailureMode1
                        w1 }) -}
d7a7deaccc0b1801756dfe525f0a4cfd
  $wa ::
    GHC.Base.Maybe a
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Array# Database.Memcache.Server.Server
    -> Database.Memcache.Cluster.FailureMode
    -> Database.Memcache.Cluster.FailureMode
    -> GHC.Prim.Int#
    -> (Database.Memcache.Server.Server -> GHC.Types.IO a)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [(Database.Memcache.Server.Server, a)] #)
  {- Arity: 9,
     Strictness: <L,U><L,U><L,U><L,U><S,U><S,H><L,U><L,C(U)><L,U>,
     Inline: [0],
     Unfolding: (\ @ a1
                   w :: GHC.Base.Maybe a1
                   ww :: GHC.Prim.Int#
                   ww1 :: GHC.Prim.Int#
                   ww2 :: GHC.Prim.Array# Database.Memcache.Server.Server
                   ww3 :: Database.Memcache.Cluster.FailureMode
                   ww4 :: Database.Memcache.Cluster.FailureMode
                   ww5 :: GHC.Prim.Int#
                   w1 :: Database.Memcache.Server.Server -> GHC.Types.IO a1
                   w2 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.Prim.newArray#
                        @ a1
                        @ (Control.Monad.Primitive.PrimState GHC.Types.IO)
                        ww1
                        (Data.Vector.Mutable.uninitialised @ a1)
                        w2
                          `cast`
                        (GHC.Prim.State#
                           (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R of ds1 { (#,#) ipv ipv1 ->
                 let {
                   ds :: Data.Vector.Vector Database.Memcache.Server.Server
                   = Data.Vector.Vector @ Database.Memcache.Server.Server ww ww1 ww2
                 } in
                 let {
                   wild :: Database.Memcache.Cluster.Cluster
                   = Database.Memcache.Cluster.Cluster ds ww3 ww4 ww5
                 } in
                 letrec {
                   $wa2 :: GHC.Types.SPEC
                           -> GHC.Prim.Int#
                           -> GHC.Prim.Int#
                           -> GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
                     {- Arity: 4, Strictness: <S,1*U><L,U><L,U><L,U>, Inline: [0] -}
                   = \ w3 :: GHC.Types.SPEC
                       ww6 :: GHC.Prim.Int#
                       ww7 :: GHC.Prim.Int#
                       w4 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                     case w3 of ds5 { DEFAULT ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# ww7 ww1) of wild2 {
                       GHC.Types.False
                       -> case GHC.Prim.indexArray#
                                 @ Database.Memcache.Server.Server
                                 ww2
                                 (GHC.Prim.+# ww ww7) of ds2 { (##) ipv2 ->
                          case Database.Memcache.Cluster.allOp3
                                 @ a1
                                 w
                                 wild
                                 ipv2
                                 w1
                                 w4 of ds4 { (#,#) ipv3 ipv4 ->
                          case GHC.Prim.writeArray#
                                 @ (Control.Monad.Primitive.PrimState GHC.Types.IO)
                                 @ a1
                                 ipv1
                                 ww6
                                 ipv4
                                 ipv3
                                   `cast`
                                 (GHC.Prim.State#
                                    (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R of s'# { DEFAULT ->
                          $wa2
                            GHC.Types.SPEC
                            (GHC.Prim.+# ww6 1)
                            (GHC.Prim.+# ww7 1)
                            s'#
                              `cast`
                            (GHC.Prim.State#
                               (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))_R } } }
                       GHC.Types.True -> (# w4, GHC.Types.I# ww6 #) } }
                 } in
                 case $wa2
                        GHC.Types.SPEC
                        0
                        0
                        ipv
                          `cast`
                        (GHC.Prim.State#
                           (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))_R of ds2 { (#,#) ipv2 ipv3 ->
                 case ipv3 of dt5 { GHC.Types.I# dt6 ->
                 case GHC.Prim.unsafeFreezeArray#
                        @ (Control.Monad.Primitive.PrimState GHC.Types.IO)
                        @ a1
                        ipv1
                        ipv2
                          `cast`
                        (GHC.Prim.State#
                           (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R of ds3 { (#,#) ipv4 ipv5 ->
                 (# ipv4
                      `cast`
                    (GHC.Prim.State#
                       (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))_R,
                    letrec {
                      $wgo :: GHC.Types.Int
                              -> GHC.Types.Int
                              -> GHC.Base.Maybe Database.Memcache.Server.Server
                              -> [(Database.Memcache.Server.Server, a1)]
                        {- Arity: 3, Strictness: <L,1*U(U)><L,1*U(U)><S,1*U>,
                           Inline: [0] -}
                      = \ ww6 :: GHC.Types.Int
                          ww7 :: GHC.Types.Int
                          ww8 :: GHC.Base.Maybe Database.Memcache.Server.Server ->
                        case ww8 of wild5 {
                          GHC.Base.Nothing
                          -> case ww6 of wild1 { GHC.Types.I# x ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x ww1) of wild2 {
                               GHC.Types.False
                               -> case GHC.Prim.indexArray#
                                         @ Database.Memcache.Server.Server
                                         ww2
                                         (GHC.Prim.+# ww x) of ds4 { (##) ipv6 ->
                                  $wgo
                                    (GHC.Types.I# (GHC.Prim.+# x 1))
                                    ww7
                                    (GHC.Base.Just @ Database.Memcache.Server.Server ipv6) }
                               GHC.Types.True
                               -> GHC.Types.[] @ (Database.Memcache.Server.Server, a1) } }
                          GHC.Base.Just x
                          -> case ww7 of wild1 { GHC.Types.I# x1 ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x1 dt6) of wild2 {
                               GHC.Types.False
                               -> case GHC.Prim.indexArray# @ a1 ipv5 x1 of ds4 { (##) ipv6 ->
                                  GHC.Types.:
                                    @ (Database.Memcache.Server.Server, a1)
                                    (x, ipv6)
                                    ($wgo
                                       ww6
                                       (GHC.Types.I# (GHC.Prim.+# x1 1))
                                       (GHC.Base.Nothing @ Database.Memcache.Server.Server)) }
                               GHC.Types.True
                               -> GHC.Types.[] @ (Database.Memcache.Server.Server, a1) } } }
                    } in
                    $wgo
                      Database.Memcache.Cluster.allOp2
                      Database.Memcache.Cluster.allOp2
                      (GHC.Base.Nothing @ Database.Memcache.Server.Server) #) } } } }) -}
ab9b7e496141f8c6629bacdb10240fe8
  $wa1 ::
    [Database.Memcache.Cluster.ServerSpec]
    -> Database.Memcache.Cluster.FailureMode
    -> Database.Memcache.Cluster.FailureMode
    -> GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Database.Memcache.Cluster.Cluster #)
  {- Arity: 5, Strictness: <S,1*U><S,U><S,U><L,U><L,U>, Inline: [0],
     Unfolding: (\ w :: [Database.Memcache.Cluster.ServerSpec]
                   ww :: Database.Memcache.Cluster.FailureMode
                   ww1 :: Database.Memcache.Cluster.FailureMode
                   ww2 :: GHC.Prim.Int#
                   w1 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Database.Memcache.Cluster.newCluster3
                        w
                        w1 of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    Database.Memcache.Cluster.Cluster
                      (GHC.ST.runSTRep
                         @ (Data.Vector.Vector Database.Memcache.Server.Server)
                         (\ @ s s1 :: GHC.Prim.State# s[OneShot] ->
                          case GHC.Prim.newArray#
                                 @ Database.Memcache.Server.Server
                                 @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                 0
                                 (Data.Vector.Mutable.uninitialised
                                    @ Database.Memcache.Server.Server)
                                 s1
                                   `cast`
                                 (GHC.Prim.State#
                                    (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                              <s>_N)))_R of ds2 { (#,#) ipv2 ipv3 ->
                          case Database.Memcache.Cluster.newCluster2
                                 @ s
                                 GHC.Types.SPEC
                                 ((Data.Vector.Mutable.MVector
                                     @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                     @ Database.Memcache.Server.Server
                                     0
                                     0
                                     ipv3)
                                    `cast`
                                  (Sub (Sym (Data.Vector.TFCo:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                      (GHC.ST.ST
                                                                                         s)>_N <Database.Memcache.Server.Server>_N),
                                  Database.Memcache.Cluster.allOp2)
                                 (Data.OldList.sortBy
                                    @ Database.Memcache.Server.Server
                                    Database.Memcache.Server.$fOrdServer_$ccompare
                                    ipv1)
                                 ipv2
                                   `cast`
                                 (GHC.Prim.State#
                                    (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                         <s>_N))_R of ds3 { (#,#) ipv6 ipv7 ->
                          case ipv7 of wild5 { (,) v' n ->
                          case v'
                                 `cast`
                               (Sub (Data.Vector.TFCo:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                             (GHC.ST.ST
                                                                                s)>_N <Database.Memcache.Server.Server>_N) of wild { Data.Vector.Mutable.MVector dt dt1 dt2 ->
                          case n of dt5 { GHC.Types.I# dt6 ->
                          case GHC.Prim.unsafeFreezeArray#
                                 @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                 @ Database.Memcache.Server.Server
                                 dt2
                                 ipv6
                                   `cast`
                                 (GHC.Prim.State#
                                    (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                              <s>_N)))_R of ds4 { (#,#) ipv4 ipv5 ->
                          (# ipv4
                               `cast`
                             (GHC.Prim.State#
                                (Control.Monad.Primitive.TFCo:R:PrimStateST[0] <s>_N))_R,
                             Data.Vector.Vector
                               @ Database.Memcache.Server.Server
                               dt
                               dt6
                               ipv5 #) } } } } } }))
                      ww
                      ww1
                      ww2 #) }) -}
81936693186238b83f78cd265848a1d7
  data Cluster
    = Cluster {servers :: Data.Vector.Vector
                            Database.Memcache.Server.Server,
               cmdFailureMode :: !Database.Memcache.Cluster.FailureMode,
               _serverFailureMode :: !Database.Memcache.Cluster.FailureMode,
               serverRetries :: {-# UNPACK #-}GHC.Types.Int}
4dfe320a13af7a30ce05d8b404499ba3
  data FailureMode = FailSilent | FailToBackup | FailToError
    Promotable
fc18d622617f251e044e3992911eadf1
  data Options
    = Options {optsCmdFailure :: !Database.Memcache.Cluster.FailureMode,
               optsServerFailure :: !Database.Memcache.Cluster.FailureMode,
               optsServerRetries :: {-# UNPACK #-}GHC.Types.Int}
a08578e0995ed5745bba893eff005b7f
  data ServerSpec
    = ServerSpec {ssHost :: Network.Socket.HostName,
                  ssPort :: Network.Socket.Types.PortNumber,
                  ssAuth :: Database.Memcache.Types.Authentication}
ea0aaf85ed20872ec62762097451e31b
  _serverFailureMode ::
    Database.Memcache.Cluster.Cluster
    -> Database.Memcache.Cluster.FailureMode
  RecSel Database.Memcache.Cluster.Cluster
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSSL),1*U(A,1*H,U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Cluster.Cluster ->
                 case ds of wild { Database.Memcache.Cluster.Cluster ds1 ds2 ds3 dt ->
                 ds3 }) -}
4f1b168e06753a2aa2d3ac698045db06
  allOp ::
    GHC.Base.Maybe a
    -> Database.Memcache.Cluster.Cluster
    -> (Database.Memcache.Server.Server -> GHC.Types.IO a)
    -> GHC.Types.IO [(Database.Memcache.Server.Server, a)]
  {- Arity: 4,
     Strictness: <L,U><S(SSSL),1*U(1*U(U,U,U),U,H,U)><L,C(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Cluster.allOp1
                  `cast`
                (forall a1.
                 <GHC.Base.Maybe a1>_R
                 ->_R <Database.Memcache.Cluster.Cluster>_R
                 ->_R <Database.Memcache.Server.Server -> GHC.Types.IO a1>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0]
                               <[(Database.Memcache.Server.Server, a1)]>_R)) -}
b36cf316f6f34e29700096dff77142d9
  allOp1 ::
    GHC.Base.Maybe a
    -> Database.Memcache.Cluster.Cluster
    -> (Database.Memcache.Server.Server -> GHC.Types.IO a)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [(Database.Memcache.Server.Server, a)] #)
  {- Arity: 4,
     Strictness: <L,U><S(SSSL),1*U(1*U(U,U,U),U,H,U)><L,C(U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a1
                   w :: GHC.Base.Maybe a1
                   w1 :: Database.Memcache.Cluster.Cluster
                   w2 :: Database.Memcache.Server.Server -> GHC.Types.IO a1
                   w3 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case w1 of ww { Database.Memcache.Cluster.Cluster ww1 ww2 ww3 ww4 ->
                 case ww1 of ww5 { Data.Vector.Vector ww6 ww7 ww8 ->
                 Database.Memcache.Cluster.$wa
                   @ a1
                   w
                   ww6
                   ww7
                   ww8
                   ww2
                   ww3
                   ww4
                   w2
                   w3 } }) -}
f37db1eae01dff06f339f2b1d9f69729
  allOp2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
3efb65a5c5d0fdc84ac47284a5a5467b
  allOp3 ::
    GHC.Base.Maybe a
    -> Database.Memcache.Cluster.Cluster
    -> Database.Memcache.Server.Server
    -> (Database.Memcache.Server.Server -> GHC.Types.IO a)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
  {- Arity: 5, Strictness: <L,U><L,U(A,U,H,U)><L,U><L,1*C1(U)><L,U>,
     Unfolding: (\ @ a1
                   def :: GHC.Base.Maybe a1
                   c :: Database.Memcache.Cluster.Cluster
                   s :: Database.Memcache.Server.Server
                   m :: Database.Memcache.Server.Server -> GHC.Types.IO a1
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 let {
                   lvl11 :: GHC.Types.IO a1 = m s
                 } in
                 letrec {
                   a2 :: GHC.Types.Int
                         -> GHC.Prim.State# GHC.Prim.RealWorld
                         -> (# GHC.Prim.State# GHC.Prim.RealWorld, a1 #)
                     {- Arity: 2, Strictness: <L,U(U)><L,U> -}
                   = \ attempt :: GHC.Types.Int
                       eta1 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                     Control.Exception.catches1
                       @ a1
                       lvl11
                       (GHC.Types.:
                          @ (Control.Exception.Handler a1)
                          (Control.Exception.Handler
                             @ a1
                             @ Database.Memcache.Errors.MemcacheError
                             Database.Memcache.Errors.$fExceptionMemcacheError
                             (let {
                                ds :: GHC.Types.Int
                                = case attempt of wild { GHC.Types.I# x ->
                                  GHC.Types.I# (GHC.Prim.-# x 1) }
                              } in
                              (\ err :: Database.Memcache.Errors.MemcacheError
                                 eta2 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                               case ds of wild { GHC.Types.I# ds1 ->
                               case ds1 of ds2 {
                                 DEFAULT
                                 -> case err of wild1 {
                                      DEFAULT
                                      -> GHC.Prim.raiseIO#
                                           @ GHC.Exception.SomeException
                                           @ a1
                                           (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                              wild1)
                                           eta2
                                      Database.Memcache.Errors.MemErrStoreFailed -> a2 wild eta2
                                      Database.Memcache.Errors.MemErrUnknownCmd -> a2 wild eta2 }
                                 0
                                 -> case c of wild1 { Database.Memcache.Cluster.Cluster ds3 ds4 ds5 dt ->
                                    case ds4 of wild2 {
                                      Database.Memcache.Cluster.FailSilent
                                      -> case def of wild3 {
                                           GHC.Base.Nothing
                                           -> GHC.Prim.raiseIO#
                                                @ GHC.Exception.SomeException
                                                @ a1
                                                (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                                   err)
                                                eta2
                                           GHC.Base.Just x -> (# eta2, x #) }
                                      Database.Memcache.Cluster.FailToBackup
                                      -> case GHC.Err.undefined
                                         ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld, a1 #)
                                         of {}
                                      Database.Memcache.Cluster.FailToError
                                      -> GHC.Prim.raiseIO#
                                           @ GHC.Exception.SomeException
                                           @ a1
                                           (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                              err)
                                           eta2 } } } })
                                `cast`
                              (<Database.Memcache.Errors.MemcacheError>_R
                               ->_R Sym (GHC.Types.NTCo:IO[0] <a1>_R))))
                          (GHC.Types.:
                             @ (Control.Exception.Handler a1)
                             (Control.Exception.Handler
                                @ a1
                                @ GHC.Exception.SomeException
                                GHC.Exception.$fExceptionSomeException
                                (let {
                                   ds :: GHC.Types.Int
                                   = case attempt of wild { GHC.Types.I# x ->
                                     GHC.Types.I# (GHC.Prim.-# x 1) }
                                 } in
                                 (\ err :: GHC.Exception.SomeException
                                    eta2 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                                  case ds of wild { GHC.Types.I# ds1 ->
                                  case ds1 of ds2 {
                                    DEFAULT -> a2 wild eta2
                                    0
                                    -> case c of wild1 { Database.Memcache.Cluster.Cluster ds3 ds4 ds5 dt ->
                                       case ds4 of wild2 {
                                         Database.Memcache.Cluster.FailSilent
                                         -> case def of wild3 {
                                              GHC.Base.Nothing
                                              -> GHC.Prim.raiseIO#
                                                   @ GHC.Exception.SomeException
                                                   @ a1
                                                   err
                                                   eta2
                                              GHC.Base.Just x -> (# eta2, x #) }
                                         Database.Memcache.Cluster.FailToBackup
                                         -> case GHC.Err.undefined
                                            ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld, a1 #)
                                            of {}
                                         Database.Memcache.Cluster.FailToError
                                         -> GHC.Prim.raiseIO#
                                              @ GHC.Exception.SomeException
                                              @ a1
                                              err
                                              eta2 } } } })
                                   `cast`
                                 (<GHC.Exception.SomeException>_R
                                  ->_R Sym (GHC.Types.NTCo:IO[0] <a1>_R))))
                             (GHC.Types.[] @ (Control.Exception.Handler a1))))
                       eta1
                 } in
                 a2
                   (case c of wild { Database.Memcache.Cluster.Cluster ds ds1 ds2 dt ->
                    GHC.Types.I# dt })
                   eta) -}
1a6c0b17a57f337bc45d28812f93aad4
  anyOp ::
    GHC.Base.Maybe a
    -> Database.Memcache.Cluster.Cluster
    -> (Database.Memcache.Server.Server -> GHC.Types.IO a)
    -> GHC.Types.IO a
  {- Arity: 2, Strictness: <L,U><L,U(U(U,U,U),U,H,U)>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Cluster.anyOp1
                  `cast`
                (forall a1.
                 <GHC.Base.Maybe a1>_R
                 ->_R <Database.Memcache.Cluster.Cluster>_R
                 ->_R <Database.Memcache.Server.Server -> GHC.Types.IO a1>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <a1>_R)) -}
4a47bf6038d338a7dc7a1b28159bc7a5
  anyOp1 ::
    GHC.Base.Maybe a
    -> Database.Memcache.Cluster.Cluster
    -> (Database.Memcache.Server.Server -> GHC.Types.IO a)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
  {- Arity: 2, Strictness: <L,U><L,U(U(U,U,U),U,H,U)>,
     Unfolding: (\ @ a1
                   def :: GHC.Base.Maybe a1
                   c :: Database.Memcache.Cluster.Cluster ->
                 Database.Memcache.Cluster.allOp3
                   @ a1
                   def
                   c
                   (case c of wild { Database.Memcache.Cluster.Cluster ds ds1 ds2 dt ->
                    case Data.Vector.Generic.length
                           @ Data.Vector.Vector
                           @ Database.Memcache.Server.Server
                           Database.Memcache.Cluster.anyOp3
                           ds of wild3 { GHC.Types.I# y ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<# 0 y) of wild4 {
                      GHC.Types.False -> Database.Memcache.Cluster.anyOp2 y
                      GHC.Types.True
                      -> case ds of wild1 { Data.Vector.Vector dt1 dt2 dt3 ->
                         case GHC.Prim.indexArray#
                                @ Database.Memcache.Server.Server
                                dt3
                                dt1 of ds3 { (##) ipv ->
                         ipv } } } } })) -}
ae2f2e0c23ba3c271b4be7e7332fbf82
  anyOp2 :: GHC.Prim.Int# -> Database.Memcache.Server.Server
  {- Arity: 1, Strictness: <L,U>b -}
52b2708ab7410e8478a54e2fbcd3aa8c
  anyOp3 ::
    Data.Vector.Generic.Base.Vector
      Data.Vector.Vector Database.Memcache.Server.Server
  {- Unfolding: (Data.Vector.$fVectorVectora
                   @ Database.Memcache.Server.Server
                   (Data.Vector.Mutable.$fMVectorMVectora
                      @ Database.Memcache.Server.Server)
                     `cast`
                   (Data.Vector.Generic.Mutable.Base.MVector
                      (Sym (Data.Vector.TFCo:R:MutableVector[0]))
                      <Database.Memcache.Server.Server>_N)_R) -}
0b249fabbd43f579025a7ed5591b523f
  cmdFailureMode ::
    Database.Memcache.Cluster.Cluster
    -> Database.Memcache.Cluster.FailureMode
  RecSel Database.Memcache.Cluster.Cluster
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSSL),1*U(A,U,1*H,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Cluster.Cluster ->
                 case ds of wild { Database.Memcache.Cluster.Cluster ds1 ds2 ds3 dt ->
                 ds2 }) -}
5d89e570331746c0795c5afaf5a08d0c
  defaultOptions :: Database.Memcache.Cluster.Options
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Database.Memcache.Cluster.Options
                   Database.Memcache.Cluster.FailToError
                   Database.Memcache.Cluster.FailToError
                   2) -}
9fe13e86ebc816fbfb6a2f3405bb7092
  defaultServerSpec :: Database.Memcache.Cluster.ServerSpec
  {- Strictness: m,
     Unfolding: (Database.Memcache.Cluster.ServerSpec
                   Database.Memcache.Cluster.defaultServerSpec2
                   Database.Memcache.Cluster.defaultServerSpec1
                   Database.Memcache.Types.NoAuth) -}
b57292e8a37b7ac2b524f669ee546a72
  defaultServerSpec1 :: Network.Socket.Types.PortNumber
  {- Unfolding: (case {__pkg_ccall network-2.6.2.1@netwo_A6pE0dLgMEk2GtUa1JtTJQ htons GHC.Prim.Word#
                                                                                      -> GHC.Prim.State#
                                                                                           GHC.Prim.RealWorld
                                                                                      -> (# GHC.Prim.State#
                                                                                              GHC.Prim.RealWorld,
                                                                                            GHC.Prim.Word# #)}
                        __word 11211
                        GHC.Prim.realWorld# of wild1 { (#,#) ds ds1 ->
                 (GHC.Word.W16# (GHC.Prim.narrow16Word# ds1))
                   `cast`
                 (Sym (Network.Socket.Types.NTCo:PortNumber[0])) }) -}
bf2fdca4d305a0a30762b3b0663cdb9d
  defaultServerSpec2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "localhost"#) -}
9155453f008c446f003d20c6725ed240
  keyedOp ::
    GHC.Base.Maybe a
    -> Database.Memcache.Cluster.Cluster
    -> Database.Memcache.Types.Key
    -> (Database.Memcache.Server.Server -> GHC.Types.IO a)
    -> GHC.Types.IO a
  {- Arity: 3,
     Strictness: <L,U><L,U(1*U(U,U,U),U,H,U)><L,1*U(U,U,U,U)>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Cluster.keyedOp1
                  `cast`
                (forall a1.
                 <GHC.Base.Maybe a1>_R
                 ->_R <Database.Memcache.Cluster.Cluster>_R
                 ->_R <Database.Memcache.Types.Key>_R
                 ->_R <Database.Memcache.Server.Server -> GHC.Types.IO a1>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <a1>_R)) -}
3d3f346e6594f07eb51c19956f9ebcc5
  keyedOp1 ::
    GHC.Base.Maybe a
    -> Database.Memcache.Cluster.Cluster
    -> Database.Memcache.Types.Key
    -> (Database.Memcache.Server.Server -> GHC.Types.IO a)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
  {- Arity: 3,
     Strictness: <L,U><L,U(1*U(U,U,U),U,H,U)><L,1*U(U,U,U,U)>,
     Unfolding: (\ @ a1
                   def :: GHC.Base.Maybe a1
                   c :: Database.Memcache.Cluster.Cluster
                   k :: Database.Memcache.Types.Key ->
                 Database.Memcache.Cluster.allOp3
                   @ a1
                   def
                   c
                   (case c of wild { Database.Memcache.Cluster.Cluster ds ds1 ds2 dt ->
                    case ds of v2 { Data.Vector.Vector ipv ipv1 ipv2 ->
                    let {
                      hashedKey :: GHC.Types.Int
                      = case k of wild1 { Data.ByteString.Internal.PS dt1 dt2 dt3 dt4 ->
                        case {__pkg_ccall hashable-1.2.4.0@hasha_8GjadD03dR57AKCJdr90LD hashable_fnv_hash GHC.Prim.Addr#
                                                                                                          -> GHC.Prim.Int#
                                                                                                          -> GHC.Prim.Int#
                                                                                                          -> GHC.Prim.State#
                                                                                                               GHC.Prim.RealWorld
                                                                                                          -> (# GHC.Prim.State#
                                                                                                                  GHC.Prim.RealWorld,
                                                                                                                GHC.Prim.Int# #)}
                               (GHC.Prim.plusAddr# dt1 dt3)
                               dt4
                               (-2578643520546668380)
                               GHC.Prim.realWorld# of wild2 { (#,#) ds3 ds4 ->
                        case GHC.Prim.touch#
                               @ GHC.ForeignPtr.ForeignPtrContents
                               dt2
                               ds3 of s' { DEFAULT ->
                        GHC.Types.I# ds4 } } }
                    } in
                    letrec {
                      $wfind_loop :: GHC.Types.SPEC
                                     -> GHC.Prim.Int#
                                     -> Data.Vector.Fusion.Util.Id
                                          (GHC.Base.Maybe Database.Memcache.Server.Server)
                        {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                      = \ w :: GHC.Types.SPEC ww :: GHC.Prim.Int# ->
                        case w of ds5 { DEFAULT ->
                        case GHC.Prim.tagToEnum#
                               @ GHC.Types.Bool
                               (GHC.Prim.>=# ww ipv1) of wild2 {
                          GHC.Types.False
                          -> case GHC.Prim.indexArray#
                                    @ Database.Memcache.Server.Server
                                    ipv2
                                    (GHC.Prim.+# ipv ww) of ds3 { (##) ipv3 ->
                             case ipv3 of wild1 { Database.Memcache.Server.Server dt1 ds4 ds6 dt2 ds7 ds8 ->
                             case hashedKey of wild3 { GHC.Types.I# y ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.<# dt1 y) of wild4 {
                               GHC.Types.False -> $wfind_loop GHC.Types.SPEC (GHC.Prim.+# ww 1)
                               GHC.Types.True
                               -> (GHC.Base.Just @ Database.Memcache.Server.Server wild1)
                                    `cast`
                                  (Sym (Data.Vector.Fusion.Util.NTCo:Id[0]
                                            <GHC.Base.Maybe
                                               Database.Memcache.Server.Server>_R)) } } } }
                          GHC.Types.True
                          -> (GHC.Base.Nothing @ Database.Memcache.Server.Server)
                               `cast`
                             (Sym (Data.Vector.Fusion.Util.NTCo:Id[0]
                                       <GHC.Base.Maybe Database.Memcache.Server.Server>_R)) } }
                    } in
                    case ($wfind_loop GHC.Types.SPEC 0)
                           `cast`
                         (Data.Vector.Fusion.Util.NTCo:Id[0]
                              <GHC.Base.Maybe Database.Memcache.Server.Server>_R) of wild1 {
                      GHC.Base.Nothing
                      -> case Data.Vector.Generic.length
                                @ Data.Vector.Vector
                                @ Database.Memcache.Server.Server
                                Database.Memcache.Cluster.anyOp3
                                v2 of wild2 { GHC.Types.I# x ->
                         let {
                           x1 :: GHC.Prim.Int# = GHC.Prim.-# x 1
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.>=# x1 0) of wild3 {
                           GHC.Types.False -> Database.Memcache.Cluster.keyedOp2 x1 x
                           GHC.Types.True
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.<# x1 x) of wild4 {
                                GHC.Types.False -> Database.Memcache.Cluster.keyedOp2 x1 x
                                GHC.Types.True
                                -> case GHC.Prim.indexArray#
                                          @ Database.Memcache.Server.Server
                                          ipv2
                                          (GHC.Prim.+# ipv x1) of ds3 { (##) ipv3 ->
                                   ipv3 } } } }
                      GHC.Base.Just v -> v } } })) -}
1045665d28377e7db3b1226061cf9e2a
  keyedOp2 ::
    GHC.Prim.Int# -> GHC.Prim.Int# -> Database.Memcache.Server.Server
  {- Arity: 2, Strictness: <L,U><L,U>b -}
77712560a371e0e694fb1efa7b62daa1
  newCluster ::
    [Database.Memcache.Cluster.ServerSpec]
    -> Database.Memcache.Cluster.Options
    -> GHC.Types.IO Database.Memcache.Cluster.Cluster
  {- Arity: 3, Strictness: <S,1*U><S(SSL),1*U(U,U,U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Cluster.newCluster1
                  `cast`
                (<[Database.Memcache.Cluster.ServerSpec]>_R
                 ->_R <Database.Memcache.Cluster.Options>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0]
                               <Database.Memcache.Cluster.Cluster>_R)) -}
b45cfc4c72fddc05af1540d9140ea069
  newCluster1 ::
    [Database.Memcache.Cluster.ServerSpec]
    -> Database.Memcache.Cluster.Options
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Database.Memcache.Cluster.Cluster #)
  {- Arity: 3, Strictness: <S,1*U><S(SSL),1*U(U,U,U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: [Database.Memcache.Cluster.ServerSpec]
                   w1 :: Database.Memcache.Cluster.Options
                   w2 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case w1 of ww { Database.Memcache.Cluster.Options ww1 ww2 ww3 ->
                 Database.Memcache.Cluster.$wa1 w ww1 ww2 ww3 w2 }) -}
7408cd8a69e923b066006f21e187d963
  newCluster2 ::
    GHC.Types.SPEC
    -> (Data.Vector.Generic.Base.Mutable
          Data.Vector.Vector
          (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
          Database.Memcache.Server.Server,
        GHC.Types.Int)
    -> [Database.Memcache.Server.Server]
    -> GHC.Prim.State# s
    -> (# GHC.Prim.State# s,
          (Data.Vector.Generic.Base.Mutable
             Data.Vector.Vector
             (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
             Database.Memcache.Server.Server,
           GHC.Types.Int) #)
  {- Arity: 4, Strictness: <S,1*U><L,U(U(U,U,U),U(U))><S,1*U><L,U> -}
d764ac4d3ecabffca588ae807884e1aa
  newCluster3 ::
    [Database.Memcache.Cluster.ServerSpec]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [Database.Memcache.Server.Server] #)
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
1417a3accf1d8081254be3a5bdc9859d
  optsCmdFailure ::
    Database.Memcache.Cluster.Options
    -> Database.Memcache.Cluster.FailureMode
  RecSel Database.Memcache.Cluster.Options
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SSL),1*U(U,1*H,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Cluster.Options ->
                 case ds of wild { Database.Memcache.Cluster.Options ds1 ds2 dt ->
                 ds1 }) -}
0545a6ab23080a1aa0af2dd25fdca71b
  optsServerFailure ::
    Database.Memcache.Cluster.Options
    -> Database.Memcache.Cluster.FailureMode
  RecSel Database.Memcache.Cluster.Options
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SSL),1*U(1*H,U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Cluster.Options ->
                 case ds of wild { Database.Memcache.Cluster.Options ds1 ds2 dt ->
                 ds2 }) -}
55d38b380f8f6c6e8bc1d170cfebd2f7
  optsServerRetries ::
    Database.Memcache.Cluster.Options -> GHC.Types.Int
  RecSel Database.Memcache.Cluster.Options
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SSL),1*U(1*H,1*H,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Cluster.Options ->
                 case ds of wild { Database.Memcache.Cluster.Options ds1 ds2 dt ->
                 GHC.Types.I# dt }) -}
d431e60f0244db55fb509f18c7118e6f
  serverRetries :: Database.Memcache.Cluster.Cluster -> GHC.Types.Int
  RecSel Database.Memcache.Cluster.Cluster
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSSL),1*U(A,1*H,1*H,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Cluster.Cluster ->
                 case ds of wild { Database.Memcache.Cluster.Cluster ds1 ds2 ds3 dt ->
                 GHC.Types.I# dt }) -}
474601a61129668de8a544aacacc168c
  servers ::
    Database.Memcache.Cluster.Cluster
    -> Data.Vector.Vector Database.Memcache.Server.Server
  RecSel Database.Memcache.Cluster.Cluster
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SSSL),1*U(1*U(U,U,U),1*H,1*H,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Cluster.Cluster ->
                 case ds of wild { Database.Memcache.Cluster.Cluster ds1 ds2 ds3 dt ->
                 ds1 }) -}
730ad39525437778c5ad44a3f889648d
  ssAuth ::
    Database.Memcache.Cluster.ServerSpec
    -> Database.Memcache.Types.Authentication
  RecSel Database.Memcache.Cluster.ServerSpec
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Cluster.ServerSpec ->
                 case ds of wild { Database.Memcache.Cluster.ServerSpec ds1 ds2 ds3 ->
                 ds3 }) -}
1b56fc0e698a23c251498f6fe8ad65b3
  ssHost ::
    Database.Memcache.Cluster.ServerSpec -> Network.Socket.HostName
  RecSel Database.Memcache.Cluster.ServerSpec
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Cluster.ServerSpec ->
                 case ds of wild { Database.Memcache.Cluster.ServerSpec ds1 ds2 ds3 ->
                 ds1 }) -}
d00e80e6373671182a3cf8abfe9038e0
  ssPort ::
    Database.Memcache.Cluster.ServerSpec
    -> Network.Socket.Types.PortNumber
  RecSel Database.Memcache.Cluster.ServerSpec
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U(U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Cluster.ServerSpec ->
                 case ds of wild { Database.Memcache.Cluster.ServerSpec ds1 ds2 ds3 ->
                 ds2 }) -}
instance GHC.Classes.Eq [Database.Memcache.Cluster.FailureMode]
  = Database.Memcache.Cluster.$fEqFailureMode
instance GHC.Show.Show [Database.Memcache.Cluster.Cluster]
  = Database.Memcache.Cluster.$fShowCluster
instance GHC.Show.Show [Database.Memcache.Cluster.FailureMode]
  = Database.Memcache.Cluster.$fShowFailureMode
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

