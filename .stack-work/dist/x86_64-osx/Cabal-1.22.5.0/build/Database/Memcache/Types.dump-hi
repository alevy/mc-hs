
==================== FINAL INTERFACE ====================
2016-02-25 11:03:06.061196 UTC

interface memca_3Z8qUpsEDiC53dYw3oq6HZ:Database.Memcache.Types 7103
  interface hash: d4b8a5d7146239e274290d73590cf9ca
  ABI hash: 1ca9931bda88d72b9d7d6f6ee335bcb6
  export-list hash: b2f7697915662eeadb8e65de002e666b
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 67c4bc6e3498921d447d337f3236ee3e
  sig of: Nothing
  used TH splices: False
  where
exports:
  Database.Memcache.Types.emptyReq
  Database.Memcache.Types.mEMCACHE_HEADER_SIZE
  Database.Memcache.Types.Authentication{Database.Memcache.Types.Auth Database.Memcache.Types.NoAuth Database.Memcache.Types.password Database.Memcache.Types.username}
  Database.Memcache.Types.Delta
  Database.Memcache.Types.Expiration
  Database.Memcache.Types.Extras
  Database.Memcache.Types.Flags
  Database.Memcache.Types.Header{Database.Memcache.Types.Header Database.Memcache.Types.bodyLen Database.Memcache.Types.cas Database.Memcache.Types.extraLen Database.Memcache.Types.keyLen Database.Memcache.Types.op Database.Memcache.Types.opaque Database.Memcache.Types.status}
  Database.Memcache.Types.IncorrectResponse{Database.Memcache.Types.IncorrectResponse Database.Memcache.Types.increspActual Database.Memcache.Types.increspMessage}
  Database.Memcache.Types.Initial
  Database.Memcache.Types.K{Database.Memcache.Types.IncludeKey Database.Memcache.Types.NoKey}
  Database.Memcache.Types.Key
  Database.Memcache.Types.OpRequest{Database.Memcache.Types.ReqAdd Database.Memcache.Types.ReqAppend Database.Memcache.Types.ReqDecrement Database.Memcache.Types.ReqDelete Database.Memcache.Types.ReqFlush Database.Memcache.Types.ReqGAT Database.Memcache.Types.ReqGet Database.Memcache.Types.ReqIncrement Database.Memcache.Types.ReqNoop Database.Memcache.Types.ReqPrepend Database.Memcache.Types.ReqQuit Database.Memcache.Types.ReqReplace Database.Memcache.Types.ReqSASLList Database.Memcache.Types.ReqSASLStart Database.Memcache.Types.ReqSASLStep Database.Memcache.Types.ReqSet Database.Memcache.Types.ReqStat Database.Memcache.Types.ReqTouch Database.Memcache.Types.ReqVersion}
  Database.Memcache.Types.OpResponse{Database.Memcache.Types.ResAdd Database.Memcache.Types.ResAppend Database.Memcache.Types.ResDecrement Database.Memcache.Types.ResDelete Database.Memcache.Types.ResFlush Database.Memcache.Types.ResGAT Database.Memcache.Types.ResGATK Database.Memcache.Types.ResGet Database.Memcache.Types.ResGetK Database.Memcache.Types.ResIncrement Database.Memcache.Types.ResNoop Database.Memcache.Types.ResPrepend Database.Memcache.Types.ResQuit Database.Memcache.Types.ResReplace Database.Memcache.Types.ResSASLList Database.Memcache.Types.ResSASLStart Database.Memcache.Types.ResSASLStep Database.Memcache.Types.ResSet Database.Memcache.Types.ResStat Database.Memcache.Types.ResTouch Database.Memcache.Types.ResVersion}
  Database.Memcache.Types.Password
  Database.Memcache.Types.ProtocolError{Database.Memcache.Types.ProtocolError Database.Memcache.Types.protocolHeader Database.Memcache.Types.protocolMessage Database.Memcache.Types.protocolParams}
  Database.Memcache.Types.Q{Database.Memcache.Types.Loud Database.Memcache.Types.Quiet}
  Database.Memcache.Types.Request{Database.Memcache.Types.Req Database.Memcache.Types.reqCas Database.Memcache.Types.reqOp Database.Memcache.Types.reqOpaque}
  Database.Memcache.Types.Response{Database.Memcache.Types.Res Database.Memcache.Types.resCas Database.Memcache.Types.resOp Database.Memcache.Types.resOpaque Database.Memcache.Types.resStatus}
  Database.Memcache.Types.SEIncr{Database.Memcache.Types.SEIncr}
  Database.Memcache.Types.SESet{Database.Memcache.Types.SESet}
  Database.Memcache.Types.SETouch{Database.Memcache.Types.SETouch}
  Database.Memcache.Types.Status{Database.Memcache.Types.ErrInvalidArgs Database.Memcache.Types.ErrItemNotStored Database.Memcache.Types.ErrKeyExists Database.Memcache.Types.ErrKeyNotFound Database.Memcache.Types.ErrOutOfMemory Database.Memcache.Types.ErrUnknownCommand Database.Memcache.Types.ErrValueNonNumeric Database.Memcache.Types.ErrValueTooLarge Database.Memcache.Types.NoError Database.Memcache.Types.SaslAuthContinue Database.Memcache.Types.SaslAuthFail}
  Database.Memcache.Types.Username
  Database.Memcache.Types.Value
  Database.Memcache.Types.Version
module dependencies:
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0* bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6*
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:Control.Exception e9090e246fba030faecf7b81b3e8e320
import  -/  base-4.8.2.0:Data.Typeable c3fcb0780ec05399195ad3277b18d294
import  -/  base-4.8.2.0:Data.Typeable.Internal 76b09e88499fa4ff7869a34e89976afb
import  -/  base-4.8.2.0:Data.Word ec8deb535202352cc8b509b14004bcbd
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Exception 18c46fe9c5c0c3a120035f264ef32d41
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:GHC.Word 10dc88543d98000abab9695a1019767d
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString db2e56635ed30ff269e1492b64605a38
import  -/  bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString.Internal b99858e89f19feddd3dcb9e9d523065e
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
8ea464ac72c68def1a36ff30f351146e
  $fEqAuthentication ::
    GHC.Classes.Eq Database.Memcache.Types.Authentication
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.Authentication
                  Database.Memcache.Types.$fEqAuthentication_$c==
                  Database.Memcache.Types.$fEqAuthentication_$c/= -}
8ea464ac72c68def1a36ff30f351146e
  $fEqAuthentication_$c/= ::
    Database.Memcache.Types.Authentication
    -> Database.Memcache.Types.Authentication -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Database.Memcache.Types.Authentication
                   b :: Database.Memcache.Types.Authentication ->
                 case Database.Memcache.Types.$fEqAuthentication_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
8ea464ac72c68def1a36ff30f351146e
  $fEqAuthentication_$c== ::
    Database.Memcache.Types.Authentication
    -> Database.Memcache.Types.Authentication -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: Database.Memcache.Types.Authentication
                   ds1 :: Database.Memcache.Types.Authentication ->
                 case ds of wild {
                   Database.Memcache.Types.Auth a1 a2
                   -> case a1 of wild1 { Data.ByteString.Internal.PS dt dt1 dt2 dt3 ->
                      case a2 of wild2 { Data.ByteString.Internal.PS dt4 dt5 dt6 dt7 ->
                      case ds1 of wild3 {
                        Database.Memcache.Types.Auth b1 b2
                        -> case b1 of wild4 { Data.ByteString.Internal.PS dt8 dt9 dt10 dt11 ->
                           case b2 of wild5 { Data.ByteString.Internal.PS dt12 dt13 dt14 dt15 ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim./=# dt3 dt11) of wild6 {
                             GHC.Types.False
                             -> let {
                                  $j :: GHC.Prim.Void# -> GHC.Types.Bool
                                    {- Arity: 1, Strictness: <L,A> -}
                                  = \ w :: GHC.Prim.Void#[OneShot] ->
                                    case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim./=# dt7 dt15) of wild7 {
                                      GHC.Types.False
                                      -> case GHC.Prim.tagToEnum#
                                                @ GHC.Types.Bool
                                                (GHC.Prim.eqAddr# dt4 dt12) of wild8 {
                                           GHC.Types.False
                                           -> case Data.ByteString.Internal.$wcompareBytes
                                                     dt4
                                                     dt5
                                                     dt6
                                                     dt7
                                                     dt12
                                                     dt13
                                                     dt14
                                                     dt15 of wild9 {
                                                DEFAULT -> GHC.Types.False
                                                GHC.Types.EQ -> GHC.Types.True }
                                           GHC.Types.True
                                           -> case GHC.Prim.tagToEnum#
                                                     @ GHC.Types.Bool
                                                     (GHC.Prim.==# dt6 dt14) of wild9 {
                                                GHC.Types.False
                                                -> case Data.ByteString.Internal.$wcompareBytes
                                                          dt4
                                                          dt5
                                                          dt6
                                                          dt7
                                                          dt12
                                                          dt13
                                                          dt14
                                                          dt15 of wild10 {
                                                     DEFAULT -> GHC.Types.False
                                                     GHC.Types.EQ -> GHC.Types.True }
                                                GHC.Types.True -> GHC.Types.True } }
                                      GHC.Types.True -> GHC.Types.False }
                                } in
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.eqAddr# dt dt8) of wild7 {
                                  GHC.Types.False
                                  -> case Data.ByteString.Internal.$wcompareBytes
                                            dt
                                            dt1
                                            dt2
                                            dt3
                                            dt8
                                            dt9
                                            dt10
                                            dt11 of wild8 {
                                       DEFAULT -> GHC.Types.False
                                       GHC.Types.EQ -> $j GHC.Prim.void# }
                                  GHC.Types.True
                                  -> case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# dt2 dt10) of wild8 {
                                       GHC.Types.False
                                       -> case Data.ByteString.Internal.$wcompareBytes
                                                 dt
                                                 dt1
                                                 dt2
                                                 dt3
                                                 dt8
                                                 dt9
                                                 dt10
                                                 dt11 of wild9 {
                                            DEFAULT -> GHC.Types.False
                                            GHC.Types.EQ -> $j GHC.Prim.void# }
                                       GHC.Types.True -> $j GHC.Prim.void# } }
                             GHC.Types.True -> GHC.Types.False } } }
                        Database.Memcache.Types.NoAuth -> GHC.Types.False } } }
                   Database.Memcache.Types.NoAuth
                   -> case ds1 of wild1 {
                        Database.Memcache.Types.Auth ipv ipv1 -> GHC.Types.False
                        Database.Memcache.Types.NoAuth -> GHC.Types.True } }) -}
47fc59a5a05b162f38cd94795863eb39
  $fEqHeader :: GHC.Classes.Eq Database.Memcache.Types.Header
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.Header
                  Database.Memcache.Types.$fEqHeader_$c==
                  Database.Memcache.Types.$fEqHeader_$c/= -}
47fc59a5a05b162f38cd94795863eb39
  $fEqHeader_$c/= ::
    Database.Memcache.Types.Header
    -> Database.Memcache.Types.Header -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLL),1*U(1*U(U),1*U(U),1*U(U),1*U,1*U(U),1*U(U),1*U(U))><S(SLLLLLL),1*U(1*U(U),1*U(U),1*U(U),1*U,1*U(U),1*U(U),1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Database.Memcache.Types.Header
                   b :: Database.Memcache.Types.Header ->
                 case Database.Memcache.Types.$fEqHeader_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
47fc59a5a05b162f38cd94795863eb39
  $fEqHeader_$c== ::
    Database.Memcache.Types.Header
    -> Database.Memcache.Types.Header -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLL),1*U(1*U(U),1*U(U),1*U(U),1*U,1*U(U),1*U(U),1*U(U))><S(SLLLLLL),1*U(1*U(U),1*U(U),1*U(U),1*U,1*U(U),1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Database.Memcache.Types.Header
                   w1 :: Database.Memcache.Types.Header ->
                 case w of ww { Database.Memcache.Types.Header ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 case ww1 of ww8 { GHC.Word.W8# ww9 ->
                 case w1 of ww10 { Database.Memcache.Types.Header ww11 ww12 ww13 ww14 ww15 ww16 ww17 ->
                 case ww11 of ww18 { GHC.Word.W8# ww19 ->
                 Database.Memcache.Types.$w$c==
                   ww9
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww19
                   ww12
                   ww13
                   ww14
                   ww15
                   ww16
                   ww17 } } } }) -}
51406e114fcd5f8f3a7d1e46ab07ef3f
  $fEqIncorrectResponse ::
    GHC.Classes.Eq Database.Memcache.Types.IncorrectResponse
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.IncorrectResponse
                  Database.Memcache.Types.$fEqIncorrectResponse_$c==1
                  Database.Memcache.Types.$fEqIncorrectResponse_$c/= -}
51406e114fcd5f8f3a7d1e46ab07ef3f
  $fEqIncorrectResponse_$c/= ::
    Database.Memcache.Types.IncorrectResponse
    -> Database.Memcache.Types.IncorrectResponse -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U(1*U,1*U,1*U(U),1*U(U)))><S(SL),1*U(1*U,1*U(1*U,1*U,1*U(U),1*U(U)))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Database.Memcache.Types.IncorrectResponse
                   w1 :: Database.Memcache.Types.IncorrectResponse ->
                 case w of ww { Database.Memcache.Types.IncorrectResponse ww1 ww2 ->
                 case w1 of ww3 { Database.Memcache.Types.IncorrectResponse ww4 ww5 ->
                 Database.Memcache.Types.$w$c/= ww1 ww2 ww4 ww5 } }) -}
cf3a3a0f90f9c2f75ebba016c93bc71e
  $fEqIncorrectResponse_$c== ::
    Database.Memcache.Types.OpResponse
    -> Database.Memcache.Types.OpResponse -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
51406e114fcd5f8f3a7d1e46ab07ef3f
  $fEqIncorrectResponse_$c==1 ::
    Database.Memcache.Types.IncorrectResponse
    -> Database.Memcache.Types.IncorrectResponse -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U(1*U,1*U,1*U(U),1*U(U)))><S(SL),1*U(1*U,1*U(1*U,1*U,1*U(U),1*U(U)))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Database.Memcache.Types.IncorrectResponse
                   w1 :: Database.Memcache.Types.IncorrectResponse ->
                 case w of ww { Database.Memcache.Types.IncorrectResponse ww1 ww2 ->
                 case w1 of ww3 { Database.Memcache.Types.IncorrectResponse ww4 ww5 ->
                 Database.Memcache.Types.$w$c==1 ww1 ww2 ww4 ww5 } }) -}
900e0e3188debaef4afb10615d76a76e
  $fEqIncorrectResponse_$c==2 ::
    Database.Memcache.Types.Response
    -> Database.Memcache.Types.Response -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U,1*U,1*U(U),1*U(U))><S(SLLL),1*U(1*U,1*U,1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Database.Memcache.Types.Response
                   w1 :: Database.Memcache.Types.Response ->
                 case w of ww { Database.Memcache.Types.Res ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { Database.Memcache.Types.Res ww6 ww7 ww8 ww9 ->
                 Database.Memcache.Types.$w$c==2
                   ww1
                   ww2
                   ww3
                   ww4
                   ww6
                   ww7
                   ww8
                   ww9 } }) -}
8177c343328e32152fc3982cf198a5bf
  $fEqK :: GHC.Classes.Eq Database.Memcache.Types.K
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.K
                  Database.Memcache.Types.$fEqK_$c==
                  Database.Memcache.Types.$fEqK_$c/= -}
8177c343328e32152fc3982cf198a5bf
  $fEqK_$c/= ::
    Database.Memcache.Types.K
    -> Database.Memcache.Types.K -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Database.Memcache.Types.K b :: Database.Memcache.Types.K ->
                 case a of wild {
                   Database.Memcache.Types.NoKey
                   -> case b of wild1 {
                        Database.Memcache.Types.NoKey -> GHC.Types.False
                        Database.Memcache.Types.IncludeKey -> GHC.Types.True }
                   Database.Memcache.Types.IncludeKey
                   -> case b of wild1 {
                        Database.Memcache.Types.NoKey -> GHC.Types.True
                        Database.Memcache.Types.IncludeKey -> GHC.Types.False } }) -}
8177c343328e32152fc3982cf198a5bf
  $fEqK_$c== ::
    Database.Memcache.Types.K
    -> Database.Memcache.Types.K -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Database.Memcache.Types.K
                   ds1 :: Database.Memcache.Types.K ->
                 case ds of wild {
                   Database.Memcache.Types.NoKey
                   -> case ds1 of wild1 {
                        Database.Memcache.Types.NoKey -> GHC.Types.True
                        Database.Memcache.Types.IncludeKey -> GHC.Types.False }
                   Database.Memcache.Types.IncludeKey
                   -> case ds1 of wild1 {
                        Database.Memcache.Types.NoKey -> GHC.Types.False
                        Database.Memcache.Types.IncludeKey -> GHC.Types.True } }) -}
c5b4f9fcb9c0519776d09b0b646373b0
  $fEqOpRequest :: GHC.Classes.Eq Database.Memcache.Types.OpRequest
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.OpRequest
                  Database.Memcache.Types.$fEqOpRequest_$c==
                  Database.Memcache.Types.$fEqOpRequest_$c/= -}
c5b4f9fcb9c0519776d09b0b646373b0
  $fEqOpRequest_$c/= ::
    Database.Memcache.Types.OpRequest
    -> Database.Memcache.Types.OpRequest -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Database.Memcache.Types.OpRequest
                   b :: Database.Memcache.Types.OpRequest ->
                 case Database.Memcache.Types.$fEqOpRequest_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
c5b4f9fcb9c0519776d09b0b646373b0
  $fEqOpRequest_$c== ::
    Database.Memcache.Types.OpRequest
    -> Database.Memcache.Types.OpRequest -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
cf3a3a0f90f9c2f75ebba016c93bc71e
  $fEqOpResponse :: GHC.Classes.Eq Database.Memcache.Types.OpResponse
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.OpResponse
                  Database.Memcache.Types.$fEqIncorrectResponse_$c==
                  Database.Memcache.Types.$fEqOpResponse_$c/= -}
cf3a3a0f90f9c2f75ebba016c93bc71e
  $fEqOpResponse_$c/= ::
    Database.Memcache.Types.OpResponse
    -> Database.Memcache.Types.OpResponse -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Database.Memcache.Types.OpResponse
                   b :: Database.Memcache.Types.OpResponse ->
                 case Database.Memcache.Types.$fEqIncorrectResponse_$c==
                        a
                        b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
9fa9327ab0e3d012791f9397a05b9d72
  $fEqProtocolError ::
    GHC.Classes.Eq Database.Memcache.Types.ProtocolError
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.ProtocolError
                  Database.Memcache.Types.$fEqProtocolError_$c==
                  Database.Memcache.Types.$fEqProtocolError_$c/= -}
9fa9327ab0e3d012791f9397a05b9d72
  $fEqProtocolError_$c/= ::
    Database.Memcache.Types.ProtocolError
    -> Database.Memcache.Types.ProtocolError -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U,1*U)><S(SLL),1*U(1*U,1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Database.Memcache.Types.ProtocolError
                   b :: Database.Memcache.Types.ProtocolError ->
                 case Database.Memcache.Types.$fEqProtocolError_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
9fa9327ab0e3d012791f9397a05b9d72
  $fEqProtocolError_$c== ::
    Database.Memcache.Types.ProtocolError
    -> Database.Memcache.Types.ProtocolError -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U,1*U)><S(SLL),1*U(1*U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Database.Memcache.Types.ProtocolError
                   w1 :: Database.Memcache.Types.ProtocolError ->
                 case w of ww { Database.Memcache.Types.ProtocolError ww1 ww2 ww3 ->
                 case w1 of ww4 { Database.Memcache.Types.ProtocolError ww5 ww6 ww7 ->
                 Database.Memcache.Types.$w$c==3 ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
0cbe00637e51cfb9aa1e8b4a80a1f5a2
  $fEqQ :: GHC.Classes.Eq Database.Memcache.Types.Q
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.Q
                  Database.Memcache.Types.$fEqQ_$c==
                  Database.Memcache.Types.$fEqQ_$c/= -}
0cbe00637e51cfb9aa1e8b4a80a1f5a2
  $fEqQ_$c/= ::
    Database.Memcache.Types.Q
    -> Database.Memcache.Types.Q -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Database.Memcache.Types.Q b :: Database.Memcache.Types.Q ->
                 case a of wild {
                   Database.Memcache.Types.Loud
                   -> case b of wild1 {
                        Database.Memcache.Types.Loud -> GHC.Types.False
                        Database.Memcache.Types.Quiet -> GHC.Types.True }
                   Database.Memcache.Types.Quiet
                   -> case b of wild1 {
                        Database.Memcache.Types.Loud -> GHC.Types.True
                        Database.Memcache.Types.Quiet -> GHC.Types.False } }) -}
0cbe00637e51cfb9aa1e8b4a80a1f5a2
  $fEqQ_$c== ::
    Database.Memcache.Types.Q
    -> Database.Memcache.Types.Q -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Database.Memcache.Types.Q
                   ds1 :: Database.Memcache.Types.Q ->
                 case ds of wild {
                   Database.Memcache.Types.Loud
                   -> case ds1 of wild1 {
                        Database.Memcache.Types.Loud -> GHC.Types.True
                        Database.Memcache.Types.Quiet -> GHC.Types.False }
                   Database.Memcache.Types.Quiet
                   -> case ds1 of wild1 {
                        Database.Memcache.Types.Loud -> GHC.Types.False
                        Database.Memcache.Types.Quiet -> GHC.Types.True } }) -}
ea22f4eb312eac51b3d37628818241fd
  $fEqRequest :: GHC.Classes.Eq Database.Memcache.Types.Request
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.Request
                  Database.Memcache.Types.$fEqRequest_$c==
                  Database.Memcache.Types.$fEqRequest_$c/= -}
ea22f4eb312eac51b3d37628818241fd
  $fEqRequest_$c/= ::
    Database.Memcache.Types.Request
    -> Database.Memcache.Types.Request -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U(U),1*U(U))><S(SLL),1*U(1*U,1*U(U),1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Database.Memcache.Types.Request
                   b :: Database.Memcache.Types.Request ->
                 case Database.Memcache.Types.$fEqRequest_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
ea22f4eb312eac51b3d37628818241fd
  $fEqRequest_$c== ::
    Database.Memcache.Types.Request
    -> Database.Memcache.Types.Request -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U(U),1*U(U))><S(SLL),1*U(1*U,1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Database.Memcache.Types.Request
                   w1 :: Database.Memcache.Types.Request ->
                 case w of ww { Database.Memcache.Types.Req ww1 ww2 ww3 ->
                 case w1 of ww4 { Database.Memcache.Types.Req ww5 ww6 ww7 ->
                 Database.Memcache.Types.$w$c==4 ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
900e0e3188debaef4afb10615d76a76e
  $fEqResponse :: GHC.Classes.Eq Database.Memcache.Types.Response
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.Response
                  Database.Memcache.Types.$fEqIncorrectResponse_$c==2
                  Database.Memcache.Types.$fEqResponse_$c/= -}
900e0e3188debaef4afb10615d76a76e
  $fEqResponse_$c/= ::
    Database.Memcache.Types.Response
    -> Database.Memcache.Types.Response -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U,1*U,1*U(U),1*U(U))><S(SLLL),1*U(1*U,1*U,1*U(U),1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Database.Memcache.Types.Response
                   b :: Database.Memcache.Types.Response ->
                 case Database.Memcache.Types.$fEqIncorrectResponse_$c==2
                        a
                        b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
59b33ee12c2a21fcfcee5480494574f4
  $fEqSEIncr :: GHC.Classes.Eq Database.Memcache.Types.SEIncr
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.SEIncr
                  Database.Memcache.Types.$fEqSEIncr_$c==
                  Database.Memcache.Types.$fEqSEIncr_$c/= -}
59b33ee12c2a21fcfcee5480494574f4
  $fEqSEIncr_$c/= ::
    Database.Memcache.Types.SEIncr
    -> Database.Memcache.Types.SEIncr -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U(U),1*U(U),1*U(U))><S(SLL),1*U(1*U(U),1*U(U),1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Database.Memcache.Types.SEIncr
                   b :: Database.Memcache.Types.SEIncr ->
                 case Database.Memcache.Types.$fEqSEIncr_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
59b33ee12c2a21fcfcee5480494574f4
  $fEqSEIncr_$c== ::
    Database.Memcache.Types.SEIncr
    -> Database.Memcache.Types.SEIncr -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U(U),1*U(U),1*U(U))><S(SLL),1*U(1*U(U),1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Database.Memcache.Types.SEIncr
                   w1 :: Database.Memcache.Types.SEIncr ->
                 case w of ww { Database.Memcache.Types.SEIncr ww1 ww2 ww3 ->
                 case ww1 of ww4 { GHC.Word.W64# ww5 ->
                 case w1 of ww6 { Database.Memcache.Types.SEIncr ww7 ww8 ww9 ->
                 case ww7 of ww10 { GHC.Word.W64# ww11 ->
                 Database.Memcache.Types.$w$c==5
                   ww5
                   ww2
                   ww3
                   ww11
                   ww8
                   ww9 } } } }) -}
00b1c94659decc80088f37e35b25a15d
  $fEqSESet :: GHC.Classes.Eq Database.Memcache.Types.SESet
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.SESet
                  Database.Memcache.Types.$fEqSESet_$c==
                  Database.Memcache.Types.$fEqSESet_$c/= -}
00b1c94659decc80088f37e35b25a15d
  $fEqSESet_$c/= ::
    Database.Memcache.Types.SESet
    -> Database.Memcache.Types.SESet -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U(U))><S(SL),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Database.Memcache.Types.SESet
                   w1 :: Database.Memcache.Types.SESet ->
                 case w of ww { Database.Memcache.Types.SESet ww1 ww2 ->
                 case ww1 of ww3 { GHC.Word.W32# ww4 ->
                 case w1 of ww5 { Database.Memcache.Types.SESet ww6 ww7 ->
                 case ww6 of ww8 { GHC.Word.W32# ww9 ->
                 Database.Memcache.Types.$w$c/=1 ww4 ww2 ww9 ww7 } } } }) -}
00b1c94659decc80088f37e35b25a15d
  $fEqSESet_$c== ::
    Database.Memcache.Types.SESet
    -> Database.Memcache.Types.SESet -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U(U))><S(SL),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Database.Memcache.Types.SESet
                   w1 :: Database.Memcache.Types.SESet ->
                 case w of ww { Database.Memcache.Types.SESet ww1 ww2 ->
                 case ww1 of ww3 { GHC.Word.W32# ww4 ->
                 case w1 of ww5 { Database.Memcache.Types.SESet ww6 ww7 ->
                 case ww6 of ww8 { GHC.Word.W32# ww9 ->
                 Database.Memcache.Types.$w$c==6 ww4 ww2 ww9 ww7 } } } }) -}
e6d91a6d1dd224a5ee7a3f24ab184527
  $fEqSETouch :: GHC.Classes.Eq Database.Memcache.Types.SETouch
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.SETouch
                  Database.Memcache.Types.$fEqSETouch_$c==
                  Database.Memcache.Types.$fEqSETouch_$c/= -}
e6d91a6d1dd224a5ee7a3f24ab184527
  $fEqSETouch_$c/= ::
    Database.Memcache.Types.SETouch
    -> Database.Memcache.Types.SETouch -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U(U))><S(S),1*U(1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Database.Memcache.Types.SETouch
                   b :: Database.Memcache.Types.SETouch ->
                 case a of wild { Database.Memcache.Types.SETouch a1 ->
                 case b of wild1 { Database.Memcache.Types.SETouch b1 ->
                 case a1 of wild2 { GHC.Word.W32# a2 ->
                 case b1 of wild3 { GHC.Word.W32# b2 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# a2 b2) of wild4 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } } } }) -}
e6d91a6d1dd224a5ee7a3f24ab184527
  $fEqSETouch_$c== ::
    Database.Memcache.Types.SETouch
    -> Database.Memcache.Types.SETouch -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U(U))><S(S),1*U(1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Database.Memcache.Types.SETouch
                   ds1 :: Database.Memcache.Types.SETouch ->
                 case ds of wild { Database.Memcache.Types.SETouch a1 ->
                 case ds1 of wild1 { Database.Memcache.Types.SETouch b1 ->
                 GHC.Word.$fEqWord32_$c== a1 b1 } }) -}
f71e7ee459bd0dad4eebf489e8fa8742
  $fEqStatus :: GHC.Classes.Eq Database.Memcache.Types.Status
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.Status
                  Database.Memcache.Types.$fEqStatus_$c==
                  Database.Memcache.Types.$fEqStatus_$c/= -}
f71e7ee459bd0dad4eebf489e8fa8742
  $fEqStatus_$c/= ::
    Database.Memcache.Types.Status
    -> Database.Memcache.Types.Status -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Database.Memcache.Types.Status
                   b :: Database.Memcache.Types.Status ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ Database.Memcache.Types.Status x1)
                           (GHC.Prim.dataToTag#
                              @ Database.Memcache.Types.Status
                              x2)) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
f71e7ee459bd0dad4eebf489e8fa8742
  $fEqStatus_$c== ::
    Database.Memcache.Types.Status
    -> Database.Memcache.Types.Status -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Database.Memcache.Types.Status
                   b :: Database.Memcache.Types.Status ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      (GHC.Prim.dataToTag# @ Database.Memcache.Types.Status x1)
                      (GHC.Prim.dataToTag# @ Database.Memcache.Types.Status x2)) } }) -}
51406e114fcd5f8f3a7d1e46ab07ef3f
  $fExceptionIncorrectResponse ::
    GHC.Exception.Exception Database.Memcache.Types.IncorrectResponse
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.IncorrectResponse
                  Database.Memcache.Types.$fExceptionIncorrectResponse23
                  Database.Memcache.Types.$fShowIncorrectResponse
                  Database.Memcache.Types.$fExceptionIncorrectResponse_$ctoException
                  Database.Memcache.Types.$fExceptionIncorrectResponse_$cfromException
                  Database.Memcache.Types.$fExceptionIncorrectResponse_$cdisplayException -}
ecd21b97922f87e6658421f1835eeebd
  $fExceptionIncorrectResponse1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
27532ab0786aa62bc1e9c72392b1fa70
  $fExceptionIncorrectResponse10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SaslAuthFail"#) -}
c6fef0bc7166a3909d75f2f3f13cf570
  $fExceptionIncorrectResponse11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ErrOutOfMemory"#) -}
89607aa07b3e24367a4535467a91eab7
  $fExceptionIncorrectResponse12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ErrUnknownCommand"#) -}
0e2f76d720e084dfd846ae35b26dc7d5
  $fExceptionIncorrectResponse13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ErrValueNonNumeric"#) -}
a74d53eec16275c0ed88dc4ac8c2251c
  $fExceptionIncorrectResponse14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ErrItemNotStored"#) -}
be8a0d2088040d0f6a5d4aa9f440b48a
  $fExceptionIncorrectResponse15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ErrInvalidArgs"#) -}
80c3947ee720deb4fdf8673813fc07cc
  $fExceptionIncorrectResponse16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ErrValueTooLarge"#) -}
1dc8c5deb5b6b9e1bcb370e9d80dad00
  $fExceptionIncorrectResponse17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ErrKeyExists"#) -}
363966b29c37ad059e25816e601702f4
  $fExceptionIncorrectResponse18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ErrKeyNotFound"#) -}
5d47a88a6f92c5c57b44c9e381674fc2
  $fExceptionIncorrectResponse19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NoError"#) -}
6ec5bb2310f418750dbb8b64fe666791
  $fExceptionIncorrectResponse2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "increspActual = "#) -}
6668b4a35135c774a4dc4e1ea7958f3a
  $fExceptionIncorrectResponse20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "resStatus = "#) -}
8474632a045fb6dde5a2e1a6194d1708
  $fExceptionIncorrectResponse21 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "resOp = "#) -}
fccd97a0caa19fd64f6b04d04e675643
  $fExceptionIncorrectResponse22 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
51406e114fcd5f8f3a7d1e46ab07ef3f
  $fExceptionIncorrectResponse23 ::
    Data.Typeable.Internal.Typeable
      Database.Memcache.Types.IncorrectResponse
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Types.$fExceptionIncorrectResponse24
                  `cast`
                (Sym (Data.Typeable.Internal.NTCo:Typeable[0]
                          <*>_N <Database.Memcache.Types.IncorrectResponse>_N)) -}
51406e114fcd5f8f3a7d1e46ab07ef3f
  $fExceptionIncorrectResponse24 ::
    GHC.Prim.Proxy# Database.Memcache.Types.IncorrectResponse
    -> Data.Typeable.Internal.TypeRep
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ wild :: GHC.Prim.Proxy#
                             Database.Memcache.Types.IncorrectResponse ->
                 Database.Memcache.Types.$fExceptionIncorrectResponse25) -}
2c77297baa17553c48a277ec9ba4445f
  $fExceptionIncorrectResponse25 :: Data.Typeable.Internal.TypeRep
  {- Strictness: m,
     Unfolding: (Data.Typeable.Internal.TypeRep
                   __word 5881634046261981838
                   __word 15053486754353097187
                   Database.Memcache.Types.$fExceptionIncorrectResponse_wild
                   (GHC.Types.[] @ Data.Typeable.Internal.KindRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
8bd79d06f6b18dd88204bbae966b8899
  $fExceptionIncorrectResponse3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
ef63482b7f50505a0724245828cdf5b3
  $fExceptionIncorrectResponse4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "increspMessage = "#) -}
373016dcc6bb99485102286d912c6360
  $fExceptionIncorrectResponse5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "IncorrectResponse {"#) -}
22a2318f7674dfbe69e9b6a0976b2ea0
  $fExceptionIncorrectResponse6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Res {"#) -}
fe4f8d568798dbc10741b3e4d29149d4
  $fExceptionIncorrectResponse7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "resCas = "#) -}
c02cad50f74d1cdb3c5c345c3c161e11
  $fExceptionIncorrectResponse8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "resOpaque = "#) -}
32366d74f4539cd8f16aea1fe2fb84f2
  $fExceptionIncorrectResponse9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SaslAuthContinue"#) -}
51406e114fcd5f8f3a7d1e46ab07ef3f
  $fExceptionIncorrectResponse_$cdisplayException ::
    Database.Memcache.Types.IncorrectResponse -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U,1*U(1*U,U,U(U),1*U(U)))>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Types.$fExceptionIncorrectResponse_$cshow -}
51406e114fcd5f8f3a7d1e46ab07ef3f
  $fExceptionIncorrectResponse_$cfromException ::
    GHC.Exception.SomeException
    -> GHC.Base.Maybe Database.Memcache.Types.IncorrectResponse
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ eta :: GHC.Exception.SomeException ->
                 case eta of wild { GHC.Exception.SomeException e10 $dException1 e2 ->
                 case (GHC.Exception.$p1Exception @ e10 $dException1)
                        `cast`
                      (Data.Typeable.Internal.NTCo:Typeable[0] <*>_N <e10>_N)
                        (GHC.Prim.proxy#
                           @ *
                           @ e10) of wild1 { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case dt of wild2 {
                   DEFAULT
                   -> GHC.Base.Nothing @ Database.Memcache.Types.IncorrectResponse
                   __word 5881634046261981838
                   -> case dt1 of wild3 {
                        DEFAULT
                        -> GHC.Base.Nothing @ Database.Memcache.Types.IncorrectResponse
                        __word 15053486754353097187
                        -> GHC.Base.Just
                             @ Database.Memcache.Types.IncorrectResponse
                             e2
                               `cast`
                             (UnivCo mkUnsafeCo representational e10 Database.Memcache.Types.IncorrectResponse) } } } }) -}
51406e114fcd5f8f3a7d1e46ab07ef3f
  $fExceptionIncorrectResponse_$cshow ::
    Database.Memcache.Types.IncorrectResponse -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U,1*U(1*U,U,U(U),1*U(U)))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Database.Memcache.Types.IncorrectResponse ->
                 Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
51406e114fcd5f8f3a7d1e46ab07ef3f
  $fExceptionIncorrectResponse_$cshowsPrec ::
    GHC.Types.Int
    -> Database.Memcache.Types.IncorrectResponse -> GHC.Show.ShowS
  {- Arity: 2,
     Strictness: <S,1*U(U)><S,1*U(U,1*U(1*U,U,U(U),1*U(U)))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: Database.Memcache.Types.IncorrectResponse ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Database.Memcache.Types.IncorrectResponse ww3 ww4 ->
                 Database.Memcache.Types.$w$cshowsPrec ww1 ww3 ww4 } }) -}
cf3a3a0f90f9c2f75ebba016c93bc71e
  $fExceptionIncorrectResponse_$cshowsPrec1 ::
    GHC.Types.Int
    -> Database.Memcache.Types.OpResponse -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,1*U(U)><S,1*U> -}
51406e114fcd5f8f3a7d1e46ab07ef3f
  $fExceptionIncorrectResponse_$ctoException ::
    Database.Memcache.Types.IncorrectResponse
    -> GHC.Exception.SomeException
  {- Arity: 1 -}
67264cbec463b51fcbacb4c33b5f2d90
  $fExceptionIncorrectResponse_wild :: Data.Typeable.Internal.TyCon
  {- Strictness: m,
     Unfolding: (Data.Typeable.Internal.TyCon
                   __word 5881634046261981838
                   __word 15053486754353097187
                   Database.Memcache.Types.$fExceptionIncorrectResponse_ww3
                   Database.Memcache.Types.$fExceptionIncorrectResponse_ww4
                   Database.Memcache.Types.$fExceptionIncorrectResponse_ww5) -}
f3f93c40b9816ec08a363c3721c8e618
  $fExceptionIncorrectResponse_ww3 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   "memca_3Z8qUpsEDiC53dYw3oq6HZ"#) -}
64ac7c8eeec549f337bc5a6438a404a7
  $fExceptionIncorrectResponse_ww4 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   "Database.Memcache.Types"#) -}
c392bc16206857acb3ccb44f965e56b8
  $fExceptionIncorrectResponse_ww5 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "IncorrectResponse"#) -}
9fa9327ab0e3d012791f9397a05b9d72
  $fExceptionProtocolError ::
    GHC.Exception.Exception Database.Memcache.Types.ProtocolError
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.ProtocolError
                  Database.Memcache.Types.$fExceptionProtocolError5
                  Database.Memcache.Types.$fShowProtocolError
                  Database.Memcache.Types.$fExceptionProtocolError_$ctoException
                  Database.Memcache.Types.$fExceptionProtocolError_$cfromException
                  Database.Memcache.Types.$fExceptionProtocolError_$cdisplayException -}
7cf94eb75cca40b989225aa78062afda
  $fExceptionProtocolError1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "protocolParams = "#) -}
adccc7c640c01d4b2c1fd1b73a511f73
  $fExceptionProtocolError2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "protocolHeader = "#) -}
b086ba085903f68f0ae4539bdeebe4b0
  $fExceptionProtocolError3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "protocolMessage = "#) -}
cdb1473565e8c29e710902ba3b2397cb
  $fExceptionProtocolError4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ProtocolError {"#) -}
9fa9327ab0e3d012791f9397a05b9d72
  $fExceptionProtocolError5 ::
    Data.Typeable.Internal.Typeable
      Database.Memcache.Types.ProtocolError
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Types.$fExceptionProtocolError6
                  `cast`
                (Sym (Data.Typeable.Internal.NTCo:Typeable[0]
                          <*>_N <Database.Memcache.Types.ProtocolError>_N)) -}
9fa9327ab0e3d012791f9397a05b9d72
  $fExceptionProtocolError6 ::
    GHC.Prim.Proxy# Database.Memcache.Types.ProtocolError
    -> Data.Typeable.Internal.TypeRep
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ wild :: GHC.Prim.Proxy# Database.Memcache.Types.ProtocolError ->
                 Database.Memcache.Types.$fExceptionProtocolError7) -}
baa8a5ad554d8761ab589e00b038778f
  $fExceptionProtocolError7 :: Data.Typeable.Internal.TypeRep
  {- Strictness: m,
     Unfolding: (Data.Typeable.Internal.TypeRep
                   __word 13995622222166644436
                   __word 15004346727790405318
                   Database.Memcache.Types.$fExceptionProtocolError_wild
                   (GHC.Types.[] @ Data.Typeable.Internal.KindRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
9fa9327ab0e3d012791f9397a05b9d72
  $fExceptionProtocolError_$cdisplayException ::
    Database.Memcache.Types.ProtocolError -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U,1*U,U)>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Types.$fExceptionProtocolError_$cshow -}
9fa9327ab0e3d012791f9397a05b9d72
  $fExceptionProtocolError_$cfromException ::
    GHC.Exception.SomeException
    -> GHC.Base.Maybe Database.Memcache.Types.ProtocolError
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ eta :: GHC.Exception.SomeException ->
                 case eta of wild { GHC.Exception.SomeException e10 $dException1 e2 ->
                 case (GHC.Exception.$p1Exception @ e10 $dException1)
                        `cast`
                      (Data.Typeable.Internal.NTCo:Typeable[0] <*>_N <e10>_N)
                        (GHC.Prim.proxy#
                           @ *
                           @ e10) of wild1 { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case dt of wild2 {
                   DEFAULT -> GHC.Base.Nothing @ Database.Memcache.Types.ProtocolError
                   __word 13995622222166644436
                   -> case dt1 of wild3 {
                        DEFAULT -> GHC.Base.Nothing @ Database.Memcache.Types.ProtocolError
                        __word 15004346727790405318
                        -> GHC.Base.Just
                             @ Database.Memcache.Types.ProtocolError
                             e2
                               `cast`
                             (UnivCo mkUnsafeCo representational e10 Database.Memcache.Types.ProtocolError) } } } }) -}
9fa9327ab0e3d012791f9397a05b9d72
  $fExceptionProtocolError_$cshow ::
    Database.Memcache.Types.ProtocolError -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U,1*U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Database.Memcache.Types.ProtocolError ->
                 Database.Memcache.Types.$fExceptionProtocolError_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
9fa9327ab0e3d012791f9397a05b9d72
  $fExceptionProtocolError_$cshowsPrec ::
    GHC.Types.Int
    -> Database.Memcache.Types.ProtocolError -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(U,1*U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: Database.Memcache.Types.ProtocolError ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Database.Memcache.Types.ProtocolError ww3 ww4 ww5 ->
                 Database.Memcache.Types.$w$cshowsPrec3 ww1 ww3 ww4 ww5 } }) -}
9fa9327ab0e3d012791f9397a05b9d72
  $fExceptionProtocolError_$ctoException ::
    Database.Memcache.Types.ProtocolError
    -> GHC.Exception.SomeException
  {- Arity: 1 -}
942fc38900245b6ceb30b7b291cfe64b
  $fExceptionProtocolError_wild :: Data.Typeable.Internal.TyCon
  {- Strictness: m,
     Unfolding: (Data.Typeable.Internal.TyCon
                   __word 13995622222166644436
                   __word 15004346727790405318
                   Database.Memcache.Types.$fExceptionIncorrectResponse_ww3
                   Database.Memcache.Types.$fExceptionIncorrectResponse_ww4
                   Database.Memcache.Types.$fExceptionProtocolError_ww5) -}
c012cdf87beb08f6b5af023ecb3c60d0
  $fExceptionProtocolError_ww5 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "ProtocolError"#) -}
8ea464ac72c68def1a36ff30f351146e
  $fShowAuthentication ::
    GHC.Show.Show Database.Memcache.Types.Authentication
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.Authentication
                  Database.Memcache.Types.$fShowAuthentication_$cshowsPrec
                  Database.Memcache.Types.$fShowAuthentication_$cshow
                  Database.Memcache.Types.$fShowAuthentication_$cshowList -}
8ea464ac72c68def1a36ff30f351146e
  $fShowAuthentication1 ::
    Database.Memcache.Types.Authentication -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Database.Memcache.Types.$fShowAuthentication_$cshowsPrec
                   Database.Memcache.Types.$fExceptionIncorrectResponse22) -}
923c95c8f603e0caa384601a65e1261c
  $fShowAuthentication2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NoAuth"#) -}
c32125357ef450091d843a8e3ad322e9
  $fShowAuthentication3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Auth {"#) -}
31aaa5b78b16f6f55857d9a1111676e2
  $fShowAuthentication4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "password = "#) -}
9fb5a2d4127ca806e92f22a039d531aa
  $fShowAuthentication5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "username = "#) -}
8ea464ac72c68def1a36ff30f351146e
  $fShowAuthentication_$cshow ::
    Database.Memcache.Types.Authentication -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Database.Memcache.Types.Authentication ->
                 Database.Memcache.Types.$fShowAuthentication_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8ea464ac72c68def1a36ff30f351146e
  $fShowAuthentication_$cshowList ::
    [Database.Memcache.Types.Authentication] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Database.Memcache.Types.Authentication
                   Database.Memcache.Types.$fShowAuthentication1) -}
8ea464ac72c68def1a36ff30f351146e
  $fShowAuthentication_$cshowsPrec ::
    GHC.Types.Int
    -> Database.Memcache.Types.Authentication -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a :: GHC.Types.Int
                   ds :: Database.Memcache.Types.Authentication
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   Database.Memcache.Types.Auth b1 b2
                   -> case b1 of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                      case b2 of ww7 { Data.ByteString.Internal.PS ww8 ww9 ww10 ww11 ->
                      case a of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x1 :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Database.Memcache.Types.$fShowAuthentication5
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.shows6
                               (GHC.Show.showLitString
                                  (Data.ByteString.Internal.$wunpackAppendCharsLazy
                                     ww1
                                     ww2
                                     ww3
                                     ww4
                                     (GHC.Types.[] @ GHC.Types.Char))
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.shows6
                                     (GHC.Base.++
                                        @ GHC.Types.Char
                                        Database.Memcache.Types.$fExceptionIncorrectResponse3
                                        (GHC.Base.++
                                           @ GHC.Types.Char
                                           Database.Memcache.Types.$fShowAuthentication4
                                           (GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.shows6
                                              (GHC.Show.showLitString
                                                 (Data.ByteString.Internal.$wunpackAppendCharsLazy
                                                    ww8
                                                    ww9
                                                    ww10
                                                    ww11
                                                    (GHC.Types.[] @ GHC.Types.Char))
                                                 (GHC.Types.:
                                                    @ GHC.Types.Char
                                                    GHC.Show.shows6
                                                    (GHC.Base.++
                                                       @ GHC.Types.Char
                                                       Database.Memcache.Types.$fExceptionIncorrectResponse1
                                                       x1)))))))))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Database.Memcache.Types.$fShowAuthentication3
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Database.Memcache.Types.$fShowAuthentication3
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta))) } } } }
                   Database.Memcache.Types.NoAuth
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Database.Memcache.Types.$fShowAuthentication2
                        eta }) -}
47fc59a5a05b162f38cd94795863eb39
  $fShowHeader :: GHC.Show.Show Database.Memcache.Types.Header
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.Header
                  Database.Memcache.Types.$fShowHeader_$cshowsPrec
                  Database.Memcache.Types.$fShowHeader_$cshow
                  Database.Memcache.Types.$fShowHeader_$cshowList -}
47fc59a5a05b162f38cd94795863eb39
  $fShowHeader1 :: Database.Memcache.Types.Header -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Database.Memcache.Types.Header ->
                 case w of ww { Database.Memcache.Types.Header ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 Database.Memcache.Types.$w$cshowsPrec4
                   0
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7 }) -}
47fc59a5a05b162f38cd94795863eb39
  $fShowHeader_$cshow ::
    Database.Memcache.Types.Header -> GHC.Base.String
  {- Arity: 1,
     Strictness: <S,1*U(U(U),U(U),U(U),U,U(U),U(U),1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Database.Memcache.Types.Header ->
                 Database.Memcache.Types.$fShowHeader_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
47fc59a5a05b162f38cd94795863eb39
  $fShowHeader_$cshowList ::
    [Database.Memcache.Types.Header] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Database.Memcache.Types.Header
                   Database.Memcache.Types.$fShowHeader1) -}
47fc59a5a05b162f38cd94795863eb39
  $fShowHeader_$cshowsPrec ::
    GHC.Types.Int -> Database.Memcache.Types.Header -> GHC.Show.ShowS
  {- Arity: 2,
     Strictness: <S,1*U(U)><S,1*U(U(U),U(U),U(U),U,U(U),U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Database.Memcache.Types.Header ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Database.Memcache.Types.Header ww3 ww4 ww5 ww6 ww7 ww8 ww9 ->
                 Database.Memcache.Types.$w$cshowsPrec4
                   ww1
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9 } }) -}
51406e114fcd5f8f3a7d1e46ab07ef3f
  $fShowIncorrectResponse ::
    GHC.Show.Show Database.Memcache.Types.IncorrectResponse
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.IncorrectResponse
                  Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec
                  Database.Memcache.Types.$fExceptionIncorrectResponse_$cshow
                  Database.Memcache.Types.$fShowIncorrectResponse_$cshowList -}
51406e114fcd5f8f3a7d1e46ab07ef3f
  $fShowIncorrectResponse1 ::
    Database.Memcache.Types.IncorrectResponse -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Database.Memcache.Types.IncorrectResponse ->
                 case w of ww { Database.Memcache.Types.IncorrectResponse ww1 ww2 ->
                 Database.Memcache.Types.$w$cshowsPrec 0 ww1 ww2 }) -}
51406e114fcd5f8f3a7d1e46ab07ef3f
  $fShowIncorrectResponse_$cshowList ::
    [Database.Memcache.Types.IncorrectResponse] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Database.Memcache.Types.IncorrectResponse
                   Database.Memcache.Types.$fShowIncorrectResponse1) -}
8177c343328e32152fc3982cf198a5bf
  $fShowK :: GHC.Show.Show Database.Memcache.Types.K
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.K
                  Database.Memcache.Types.$fShowK_$cshowsPrec
                  Database.Memcache.Types.$fShowK_$cshow
                  Database.Memcache.Types.$fShowK_$cshowList -}
8177c343328e32152fc3982cf198a5bf
  $fShowK1 :: Database.Memcache.Types.K -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Database.Memcache.Types.K eta :: GHC.Base.String ->
                 case ds of wild {
                   Database.Memcache.Types.NoKey
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c
                           n
                           Database.Memcache.Types.$fShowK3)
                        eta
                   Database.Memcache.Types.IncludeKey
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c
                           n
                           Database.Memcache.Types.$fShowK2)
                        eta }) -}
333aa5b14ff946278e3ecbf81c6b7cc2
  $fShowK2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "IncludeKey"#) -}
a5842ef34aec71b3d57c5d87d22c52f3
  $fShowK3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NoKey"#) -}
8177c343328e32152fc3982cf198a5bf
  $fShowK_$cshow :: Database.Memcache.Types.K -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Database.Memcache.Types.K ->
                 case x of wild {
                   Database.Memcache.Types.NoKey -> Database.Memcache.Types.$fShowK3
                   Database.Memcache.Types.IncludeKey
                   -> Database.Memcache.Types.$fShowK2 }) -}
8177c343328e32152fc3982cf198a5bf
  $fShowK_$cshowList :: [Database.Memcache.Types.K] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Database.Memcache.Types.K
                   Database.Memcache.Types.$fShowK1) -}
8177c343328e32152fc3982cf198a5bf
  $fShowK_$cshowsPrec ::
    GHC.Types.Int -> Database.Memcache.Types.K -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: Database.Memcache.Types.K
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   Database.Memcache.Types.NoKey
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c
                           n
                           Database.Memcache.Types.$fShowK3)
                        eta
                   Database.Memcache.Types.IncludeKey
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c
                           n
                           Database.Memcache.Types.$fShowK2)
                        eta }) -}
c5b4f9fcb9c0519776d09b0b646373b0
  $fShowOpRequest :: GHC.Show.Show Database.Memcache.Types.OpRequest
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.OpRequest
                  Database.Memcache.Types.$fShowOpRequest_$cshowsPrec
                  Database.Memcache.Types.$fShowOpRequest_$cshow
                  Database.Memcache.Types.$fShowOpRequest_$cshowList -}
c5b4f9fcb9c0519776d09b0b646373b0
  $fShowOpRequest1 ::
    Database.Memcache.Types.OpRequest -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (Database.Memcache.Types.$fShowOpRequest_$cshowsPrec
                   Database.Memcache.Types.$fExceptionIncorrectResponse22) -}
c5b4f9fcb9c0519776d09b0b646373b0
  $fShowOpRequest_$cshow ::
    Database.Memcache.Types.OpRequest -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Database.Memcache.Types.OpRequest ->
                 Database.Memcache.Types.$fShowOpRequest_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
c5b4f9fcb9c0519776d09b0b646373b0
  $fShowOpRequest_$cshowList ::
    [Database.Memcache.Types.OpRequest] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Database.Memcache.Types.OpRequest
                   Database.Memcache.Types.$fShowOpRequest1) -}
c5b4f9fcb9c0519776d09b0b646373b0
  $fShowOpRequest_$cshowsPrec ::
    GHC.Types.Int
    -> Database.Memcache.Types.OpRequest -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,1*U(U)><S,1*U> -}
cf3a3a0f90f9c2f75ebba016c93bc71e
  $fShowOpResponse ::
    GHC.Show.Show Database.Memcache.Types.OpResponse
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.OpResponse
                  Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                  Database.Memcache.Types.$fShowOpResponse_$cshow
                  Database.Memcache.Types.$fShowOpResponse_$cshowList -}
cf3a3a0f90f9c2f75ebba016c93bc71e
  $fShowOpResponse1 ::
    Database.Memcache.Types.OpResponse -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                   Database.Memcache.Types.$fExceptionIncorrectResponse22) -}
cf3a3a0f90f9c2f75ebba016c93bc71e
  $fShowOpResponse_$cshow ::
    Database.Memcache.Types.OpResponse -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Database.Memcache.Types.OpResponse ->
                 Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
cf3a3a0f90f9c2f75ebba016c93bc71e
  $fShowOpResponse_$cshowList ::
    [Database.Memcache.Types.OpResponse] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Database.Memcache.Types.OpResponse
                   Database.Memcache.Types.$fShowOpResponse1) -}
9fa9327ab0e3d012791f9397a05b9d72
  $fShowProtocolError ::
    GHC.Show.Show Database.Memcache.Types.ProtocolError
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.ProtocolError
                  Database.Memcache.Types.$fExceptionProtocolError_$cshowsPrec
                  Database.Memcache.Types.$fExceptionProtocolError_$cshow
                  Database.Memcache.Types.$fShowProtocolError_$cshowList -}
9fa9327ab0e3d012791f9397a05b9d72
  $fShowProtocolError1 ::
    Database.Memcache.Types.ProtocolError -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Database.Memcache.Types.ProtocolError ->
                 case w of ww { Database.Memcache.Types.ProtocolError ww1 ww2 ww3 ->
                 Database.Memcache.Types.$w$cshowsPrec3 0 ww1 ww2 ww3 }) -}
9fa9327ab0e3d012791f9397a05b9d72
  $fShowProtocolError_$cshowList ::
    [Database.Memcache.Types.ProtocolError] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Database.Memcache.Types.ProtocolError
                   Database.Memcache.Types.$fShowProtocolError1) -}
0cbe00637e51cfb9aa1e8b4a80a1f5a2
  $fShowQ :: GHC.Show.Show Database.Memcache.Types.Q
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.Q
                  Database.Memcache.Types.$fShowQ_$cshowsPrec
                  Database.Memcache.Types.$fShowQ_$cshow
                  Database.Memcache.Types.$fShowQ_$cshowList -}
0cbe00637e51cfb9aa1e8b4a80a1f5a2
  $fShowQ1 :: Database.Memcache.Types.Q -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Database.Memcache.Types.Q eta :: GHC.Base.String ->
                 case ds of wild {
                   Database.Memcache.Types.Loud
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c
                           n
                           Database.Memcache.Types.$fShowQ3)
                        eta
                   Database.Memcache.Types.Quiet
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c
                           n
                           Database.Memcache.Types.$fShowQ2)
                        eta }) -}
e216515d1efd69fe244a2df61e50f0e4
  $fShowQ2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Quiet"#) -}
35940c0345d169273298fd71d86f9c42
  $fShowQ3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Loud"#) -}
0cbe00637e51cfb9aa1e8b4a80a1f5a2
  $fShowQ_$cshow :: Database.Memcache.Types.Q -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Database.Memcache.Types.Q ->
                 case x of wild {
                   Database.Memcache.Types.Loud -> Database.Memcache.Types.$fShowQ3
                   Database.Memcache.Types.Quiet
                   -> Database.Memcache.Types.$fShowQ2 }) -}
0cbe00637e51cfb9aa1e8b4a80a1f5a2
  $fShowQ_$cshowList :: [Database.Memcache.Types.Q] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Database.Memcache.Types.Q
                   Database.Memcache.Types.$fShowQ1) -}
0cbe00637e51cfb9aa1e8b4a80a1f5a2
  $fShowQ_$cshowsPrec ::
    GHC.Types.Int -> Database.Memcache.Types.Q -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: Database.Memcache.Types.Q
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   Database.Memcache.Types.Loud
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c
                           n
                           Database.Memcache.Types.$fShowQ3)
                        eta
                   Database.Memcache.Types.Quiet
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c
                           n
                           Database.Memcache.Types.$fShowQ2)
                        eta }) -}
ea22f4eb312eac51b3d37628818241fd
  $fShowRequest :: GHC.Show.Show Database.Memcache.Types.Request
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.Request
                  Database.Memcache.Types.$fShowRequest_$cshowsPrec
                  Database.Memcache.Types.$fShowRequest_$cshow
                  Database.Memcache.Types.$fShowRequest_$cshowList -}
ea22f4eb312eac51b3d37628818241fd
  $fShowRequest1 :: Database.Memcache.Types.Request -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Database.Memcache.Types.Request ->
                 case w of ww { Database.Memcache.Types.Req ww1 ww2 ww3 ->
                 Database.Memcache.Types.$w$cshowsPrec5 0 ww1 ww2 ww3 }) -}
e4aca139d9e503e39ddd808fc4193adf
  $fShowRequest2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "reqCas = "#) -}
46dee7ccf116eebb1d576eb3bd99ac71
  $fShowRequest3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "reqOpaque = "#) -}
609782caa5782397ac0f3f84e84cf97e
  $fShowRequest4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "reqOp = "#) -}
fafb298cd35d56e7cd394450dacdebf5
  $fShowRequest5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Req {"#) -}
ea22f4eb312eac51b3d37628818241fd
  $fShowRequest_$cshow ::
    Database.Memcache.Types.Request -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,U(U),1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Database.Memcache.Types.Request ->
                 Database.Memcache.Types.$fShowRequest_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ea22f4eb312eac51b3d37628818241fd
  $fShowRequest_$cshowList ::
    [Database.Memcache.Types.Request] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Database.Memcache.Types.Request
                   Database.Memcache.Types.$fShowRequest1) -}
ea22f4eb312eac51b3d37628818241fd
  $fShowRequest_$cshowsPrec ::
    GHC.Types.Int -> Database.Memcache.Types.Request -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(1*U,U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Database.Memcache.Types.Request ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Database.Memcache.Types.Req ww3 ww4 ww5 ->
                 Database.Memcache.Types.$w$cshowsPrec5 ww1 ww3 ww4 ww5 } }) -}
900e0e3188debaef4afb10615d76a76e
  $fShowResponse :: GHC.Show.Show Database.Memcache.Types.Response
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.Response
                  Database.Memcache.Types.$fShowResponse_$cshowsPrec
                  Database.Memcache.Types.$fShowResponse_$cshow
                  Database.Memcache.Types.$fShowResponse_$cshowList -}
900e0e3188debaef4afb10615d76a76e
  $fShowResponse1 ::
    Database.Memcache.Types.Response -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Database.Memcache.Types.Response ->
                 case w of ww { Database.Memcache.Types.Res ww1 ww2 ww3 ww4 ->
                 Database.Memcache.Types.$w$cshowsPrec1 0 ww1 ww2 ww3 ww4 }) -}
900e0e3188debaef4afb10615d76a76e
  $fShowResponse_$cshow ::
    Database.Memcache.Types.Response -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,U,U(U),1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Database.Memcache.Types.Response ->
                 Database.Memcache.Types.$fShowResponse_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
900e0e3188debaef4afb10615d76a76e
  $fShowResponse_$cshowList ::
    [Database.Memcache.Types.Response] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Database.Memcache.Types.Response
                   Database.Memcache.Types.$fShowResponse1) -}
900e0e3188debaef4afb10615d76a76e
  $fShowResponse_$cshowsPrec ::
    GHC.Types.Int -> Database.Memcache.Types.Response -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(1*U,U,U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Database.Memcache.Types.Response ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Database.Memcache.Types.Res ww3 ww4 ww5 ww6 ->
                 Database.Memcache.Types.$w$cshowsPrec1 ww1 ww3 ww4 ww5 ww6 } }) -}
59b33ee12c2a21fcfcee5480494574f4
  $fShowSEIncr :: GHC.Show.Show Database.Memcache.Types.SEIncr
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.SEIncr
                  Database.Memcache.Types.$fShowSEIncr_$cshowsPrec
                  Database.Memcache.Types.$fShowSEIncr_$cshow
                  Database.Memcache.Types.$fShowSEIncr_$cshowList -}
59b33ee12c2a21fcfcee5480494574f4
  $fShowSEIncr1 :: Database.Memcache.Types.SEIncr -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Database.Memcache.Types.SEIncr ->
                 case w of ww { Database.Memcache.Types.SEIncr ww1 ww2 ww3 ->
                 Database.Memcache.Types.$w$cshowsPrec6 0 ww1 ww2 ww3 }) -}
0683d7f76a3d1d4ec76b9f8d6a87b418
  $fShowSEIncr2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SEIncr "#) -}
59b33ee12c2a21fcfcee5480494574f4
  $fShowSEIncr_$cshow ::
    Database.Memcache.Types.SEIncr -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U),1*U(U),U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Database.Memcache.Types.SEIncr ->
                 Database.Memcache.Types.$fShowSEIncr_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
59b33ee12c2a21fcfcee5480494574f4
  $fShowSEIncr_$cshowList ::
    [Database.Memcache.Types.SEIncr] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Database.Memcache.Types.SEIncr
                   Database.Memcache.Types.$fShowSEIncr1) -}
59b33ee12c2a21fcfcee5480494574f4
  $fShowSEIncr_$cshowsPrec ::
    GHC.Types.Int -> Database.Memcache.Types.SEIncr -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(1*U(U),1*U(U),U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Database.Memcache.Types.SEIncr ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Database.Memcache.Types.SEIncr ww3 ww4 ww5 ->
                 Database.Memcache.Types.$w$cshowsPrec6 ww1 ww3 ww4 ww5 } }) -}
00b1c94659decc80088f37e35b25a15d
  $fShowSESet :: GHC.Show.Show Database.Memcache.Types.SESet
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.SESet
                  Database.Memcache.Types.$fShowSESet_$cshowsPrec
                  Database.Memcache.Types.$fShowSESet_$cshow
                  Database.Memcache.Types.$fShowSESet_$cshowList -}
00b1c94659decc80088f37e35b25a15d
  $fShowSESet1 :: Database.Memcache.Types.SESet -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Database.Memcache.Types.SESet
                   w1 :: GHC.Base.String ->
                 case w of ww { Database.Memcache.Types.SESet ww1 ww2 ->
                 Database.Memcache.Types.$w$cshowsPrec7 0 ww1 ww2 w1 }) -}
4a646c6bd79adda82bdae76c6a29b139
  $fShowSESet2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SESet "#) -}
00b1c94659decc80088f37e35b25a15d
  $fShowSESet_$cshow ::
    Database.Memcache.Types.SESet -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U),1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Database.Memcache.Types.SESet ->
                 Database.Memcache.Types.$fShowSESet_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
00b1c94659decc80088f37e35b25a15d
  $fShowSESet_$cshowList ::
    [Database.Memcache.Types.SESet] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Database.Memcache.Types.SESet
                   Database.Memcache.Types.$fShowSESet1) -}
00b1c94659decc80088f37e35b25a15d
  $fShowSESet_$cshowsPrec ::
    GHC.Types.Int -> Database.Memcache.Types.SESet -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U(U),1*U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: Database.Memcache.Types.SESet
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Database.Memcache.Types.SESet ww3 ww4 ->
                 Database.Memcache.Types.$w$cshowsPrec7 ww1 ww3 ww4 w2 } }) -}
e6d91a6d1dd224a5ee7a3f24ab184527
  $fShowSETouch :: GHC.Show.Show Database.Memcache.Types.SETouch
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.SETouch
                  Database.Memcache.Types.$fShowSETouch_$cshowsPrec
                  Database.Memcache.Types.$fShowSETouch_$cshow
                  Database.Memcache.Types.$fShowSETouch_$cshowList -}
e6d91a6d1dd224a5ee7a3f24ab184527
  $fShowSETouch1 :: Database.Memcache.Types.SETouch -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Database.Memcache.Types.SETouch
                   w1 :: GHC.Base.String ->
                 case w of ww { Database.Memcache.Types.SETouch ww1 ->
                 Database.Memcache.Types.$w$cshowsPrec8 0 ww1 w1 }) -}
12b956fdeaad9b3aa0dae3a3975d72a4
  $fShowSETouch2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SETouch "#) -}
e6d91a6d1dd224a5ee7a3f24ab184527
  $fShowSETouch_$cshow ::
    Database.Memcache.Types.SETouch -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Database.Memcache.Types.SETouch ->
                 Database.Memcache.Types.$fShowSETouch_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
e6d91a6d1dd224a5ee7a3f24ab184527
  $fShowSETouch_$cshowList ::
    [Database.Memcache.Types.SETouch] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Database.Memcache.Types.SETouch
                   Database.Memcache.Types.$fShowSETouch1) -}
e6d91a6d1dd224a5ee7a3f24ab184527
  $fShowSETouch_$cshowsPrec ::
    GHC.Types.Int -> Database.Memcache.Types.SETouch -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: Database.Memcache.Types.SETouch
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Database.Memcache.Types.SETouch ww3 ->
                 Database.Memcache.Types.$w$cshowsPrec8 ww1 ww3 w2 } }) -}
f71e7ee459bd0dad4eebf489e8fa8742
  $fShowStatus :: GHC.Show.Show Database.Memcache.Types.Status
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Database.Memcache.Types.Status
                  Database.Memcache.Types.$fShowStatus_$cshowsPrec
                  Database.Memcache.Types.$fShowStatus_$cshow
                  Database.Memcache.Types.$fShowStatus_$cshowList -}
f71e7ee459bd0dad4eebf489e8fa8742
  $fShowStatus_$cshow ::
    Database.Memcache.Types.Status -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Database.Memcache.Types.Status ->
                 Database.Memcache.Types.$fShowStatus_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
f71e7ee459bd0dad4eebf489e8fa8742
  $fShowStatus_$cshowList ::
    [Database.Memcache.Types.Status] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Database.Memcache.Types.Status
                   Database.Memcache.Types.$w$cshowsPrec2) -}
f71e7ee459bd0dad4eebf489e8fa8742
  $fShowStatus_$cshowsPrec ::
    GHC.Types.Int -> Database.Memcache.Types.Status -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: Database.Memcache.Types.Status
                   w2 :: GHC.Base.String ->
                 Database.Memcache.Types.$w$cshowsPrec2 w1 w2) -}
a695ac69f1040346447998f42c90ff49
  $w$c/= ::
    GHC.Base.String
    -> Database.Memcache.Types.Response
    -> GHC.Base.String
    -> Database.Memcache.Types.Response
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(1*U,1*U,1*U(U),1*U(U))><S,1*U><L,1*U(1*U,1*U,1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Base.String
                   ww1 :: Database.Memcache.Types.Response
                   ww2 :: GHC.Base.String
                   ww3 :: Database.Memcache.Types.Response ->
                 case GHC.Base.eqString ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case ww1 of ww4 { Database.Memcache.Types.Res ww5 ww6 ww7 ww8 ->
                      case ww3 of ww9 { Database.Memcache.Types.Res ww10 ww11 ww12 ww13 ->
                      case Database.Memcache.Types.$fEqIncorrectResponse_$c==
                             ww5
                             ww10 of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True
                        -> case ww6 of x1 { DEFAULT ->
                           case ww11 of x2 { DEFAULT ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==#
                                     (GHC.Prim.dataToTag# @ Database.Memcache.Types.Status x1)
                                     (GHC.Prim.dataToTag#
                                        @ Database.Memcache.Types.Status
                                        x2)) of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True
                             -> case ww7 of wild3 { GHC.Word.W32# a1 ->
                                case ww12 of wild4 { GHC.Word.W32# b1 ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.eqWord# a1 b1) of wild5 {
                                  GHC.Types.False -> GHC.Types.True
                                  GHC.Types.True
                                  -> case ww8 of wild6 { GHC.Word.W64# a2 ->
                                     case ww13 of wild7 { GHC.Word.W64# b2 ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.eqWord# a2 b2) of wild8 {
                                       GHC.Types.False -> GHC.Types.True
                                       GHC.Types.True
                                       -> GHC.Types.False } } } } } } } } } } } } }) -}
fda018d0c3c60f5df85d5563a9954628
  $w$c/=1 ::
    GHC.Prim.Word#
    -> Database.Memcache.Types.Expiration
    -> GHC.Prim.Word#
    -> Database.Memcache.Types.Expiration
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Word#
                   ww1 :: Database.Memcache.Types.Expiration
                   ww2 :: GHC.Prim.Word#
                   ww3 :: Database.Memcache.Types.Expiration ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Word.W32# a1 ->
                      case ww3 of wild2 { GHC.Word.W32# b1 ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# a1 b1) of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
87de34e9c873b0c91127af8279d94493
  $w$c== ::
    GHC.Prim.Word#
    -> GHC.Word.Word16
    -> GHC.Word.Word8
    -> Database.Memcache.Types.Status
    -> GHC.Word.Word32
    -> GHC.Word.Word32
    -> Database.Memcache.Types.Version
    -> GHC.Prim.Word#
    -> GHC.Word.Word16
    -> GHC.Word.Word8
    -> Database.Memcache.Types.Status
    -> GHC.Word.Word32
    -> GHC.Word.Word32
    -> Database.Memcache.Types.Version
    -> GHC.Types.Bool
  {- Arity: 14, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,1*U(U)><L,1*U><L,1*U(U)><L,1*U(U)><L,1*U(U)><L,U><L,1*U(U)><L,1*U(U)><L,1*U><L,1*U(U)><L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Word#
                   ww1 :: GHC.Word.Word16
                   ww2 :: GHC.Word.Word8
                   ww3 :: Database.Memcache.Types.Status
                   ww4 :: GHC.Word.Word32
                   ww5 :: GHC.Word.Word32
                   ww6 :: Database.Memcache.Types.Version
                   ww7 :: GHC.Prim.Word#
                   ww8 :: GHC.Word.Word16
                   ww9 :: GHC.Word.Word8
                   ww10 :: Database.Memcache.Types.Status
                   ww11 :: GHC.Word.Word32
                   ww12 :: GHC.Word.Word32
                   ww13 :: Database.Memcache.Types.Version ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# ww ww7) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Word.W16# a1 ->
                      case ww8 of wild2 { GHC.Word.W16# b1 ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# a1 b1) of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case ww2 of wild4 { GHC.Word.W8# a2 ->
                           case ww9 of wild5 { GHC.Word.W8# b2 ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.eqWord# a2 b2) of wild6 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case ww3 of x1 { DEFAULT ->
                                case ww10 of x2 { DEFAULT ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==#
                                          (GHC.Prim.dataToTag# @ Database.Memcache.Types.Status x1)
                                          (GHC.Prim.dataToTag#
                                             @ Database.Memcache.Types.Status
                                             x2)) of wild7 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case ww4 of wild8 { GHC.Word.W32# a3 ->
                                     case ww11 of wild9 { GHC.Word.W32# b3 ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.eqWord# a3 b3) of wild10 {
                                       GHC.Types.False -> GHC.Types.False
                                       GHC.Types.True
                                       -> case ww5 of wild11 { GHC.Word.W32# a4 ->
                                          case ww12 of wild12 { GHC.Word.W32# b4 ->
                                          case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.eqWord# a4 b4) of wild13 {
                                            GHC.Types.False -> GHC.Types.False
                                            GHC.Types.True
                                            -> GHC.Word.$fEqWord64_$c==
                                                 ww6
                                                 ww13 } } } } } } } } } } } } } } } }) -}
4ae6b013daa7a83b6f5f57dc6bf3403e
  $w$c==1 ::
    GHC.Base.String
    -> Database.Memcache.Types.Response
    -> GHC.Base.String
    -> Database.Memcache.Types.Response
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(1*U,1*U,1*U(U),1*U(U))><S,1*U><L,1*U(1*U,1*U,1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Base.String
                   ww1 :: Database.Memcache.Types.Response
                   ww2 :: GHC.Base.String
                   ww3 :: Database.Memcache.Types.Response ->
                 case GHC.Base.eqString ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> Database.Memcache.Types.$fEqIncorrectResponse_$c==2
                        ww1
                        ww3 }) -}
e3a722ff349470575284a57b61940f8b
  $w$c==2 ::
    Database.Memcache.Types.OpResponse
    -> Database.Memcache.Types.Status
    -> GHC.Word.Word32
    -> Database.Memcache.Types.Version
    -> Database.Memcache.Types.OpResponse
    -> Database.Memcache.Types.Status
    -> GHC.Word.Word32
    -> Database.Memcache.Types.Version
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U(U)><L,1*U(U)><S,1*U><L,1*U><L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ ww :: Database.Memcache.Types.OpResponse
                   ww1 :: Database.Memcache.Types.Status
                   ww2 :: GHC.Word.Word32
                   ww3 :: Database.Memcache.Types.Version
                   ww4 :: Database.Memcache.Types.OpResponse
                   ww5 :: Database.Memcache.Types.Status
                   ww6 :: GHC.Word.Word32
                   ww7 :: Database.Memcache.Types.Version ->
                 case Database.Memcache.Types.$fEqIncorrectResponse_$c==
                        ww
                        ww4 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of x1 { DEFAULT ->
                      case ww5 of x2 { DEFAULT ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==#
                                (GHC.Prim.dataToTag# @ Database.Memcache.Types.Status x1)
                                (GHC.Prim.dataToTag#
                                   @ Database.Memcache.Types.Status
                                   x2)) of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case ww2 of wild2 { GHC.Word.W32# a1 ->
                           case ww6 of wild3 { GHC.Word.W32# b1 ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.eqWord# a1 b1) of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Word.$fEqWord64_$c== ww3 ww7 } } } } } } }) -}
955abc366b4bb4a1aee1888a8492ab73
  $w$c==3 ::
    GHC.Base.String
    -> GHC.Base.Maybe Database.Memcache.Types.Header
    -> [GHC.Base.String]
    -> GHC.Base.String
    -> GHC.Base.Maybe Database.Memcache.Types.Header
    -> [GHC.Base.String]
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Base.String
                   ww1 :: GHC.Base.Maybe Database.Memcache.Types.Header
                   ww2 :: [GHC.Base.String]
                   ww3 :: GHC.Base.String
                   ww4 :: GHC.Base.Maybe Database.Memcache.Types.Header
                   ww5 :: [GHC.Base.String] ->
                 case GHC.Base.eqString ww ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 {
                        GHC.Base.Nothing
                        -> case ww4 of wild2 {
                             GHC.Base.Nothing -> GHC.Classes.$fEq[]_$s$c==2 ww2 ww5
                             GHC.Base.Just ipv -> GHC.Types.False }
                        GHC.Base.Just a1
                        -> case ww4 of wild2 {
                             GHC.Base.Nothing -> GHC.Types.False
                             GHC.Base.Just b1
                             -> case a1 of ww6 { Database.Memcache.Types.Header ww7 ww8 ww9 ww10 ww11 ww12 ww13 ->
                                case ww7 of ww14 { GHC.Word.W8# ww15 ->
                                case b1 of ww16 { Database.Memcache.Types.Header ww17 ww18 ww19 ww20 ww21 ww22 ww23 ->
                                case ww17 of ww24 { GHC.Word.W8# ww25 ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.eqWord# ww15 ww25) of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case ww8 of wild4 { GHC.Word.W16# a2 ->
                                     case ww18 of wild5 { GHC.Word.W16# b2 ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.eqWord# a2 b2) of wild6 {
                                       GHC.Types.False -> GHC.Types.False
                                       GHC.Types.True
                                       -> case ww9 of wild7 { GHC.Word.W8# a3 ->
                                          case ww19 of wild8 { GHC.Word.W8# b3 ->
                                          case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.eqWord# a3 b3) of wild9 {
                                            GHC.Types.False -> GHC.Types.False
                                            GHC.Types.True
                                            -> case ww10 of x1 { DEFAULT ->
                                               case ww20 of x2 { DEFAULT ->
                                               case GHC.Prim.tagToEnum#
                                                      @ GHC.Types.Bool
                                                      (GHC.Prim.==#
                                                         (GHC.Prim.dataToTag#
                                                            @ Database.Memcache.Types.Status
                                                            x1)
                                                         (GHC.Prim.dataToTag#
                                                            @ Database.Memcache.Types.Status
                                                            x2)) of wild10 {
                                                 GHC.Types.False -> GHC.Types.False
                                                 GHC.Types.True
                                                 -> case ww11 of wild11 { GHC.Word.W32# a4 ->
                                                    case ww21 of wild12 { GHC.Word.W32# b4 ->
                                                    case GHC.Prim.tagToEnum#
                                                           @ GHC.Types.Bool
                                                           (GHC.Prim.eqWord# a4 b4) of wild13 {
                                                      GHC.Types.False -> GHC.Types.False
                                                      GHC.Types.True
                                                      -> case ww12 of wild14 { GHC.Word.W32# a5 ->
                                                         case ww22 of wild15 { GHC.Word.W32# b5 ->
                                                         case GHC.Prim.tagToEnum#
                                                                @ GHC.Types.Bool
                                                                (GHC.Prim.eqWord# a5 b5) of wild16 {
                                                           GHC.Types.False -> GHC.Types.False
                                                           GHC.Types.True
                                                           -> case ww13 of wild17 { GHC.Word.W64# a6 ->
                                                              case ww23 of wild18 { GHC.Word.W64# b6 ->
                                                              case GHC.Prim.tagToEnum#
                                                                     @ GHC.Types.Bool
                                                                     (GHC.Prim.eqWord#
                                                                        a6
                                                                        b6) of wild19 {
                                                                GHC.Types.False -> GHC.Types.False
                                                                GHC.Types.True
                                                                -> GHC.Classes.$fEq[]_$s$c==2
                                                                     ww2
                                                                     ww5 } } } } } } } } } } } } } } } } } } } } } } } } } }) -}
770f74670a1aaf580508d6bddec76260
  $w$c==4 ::
    Database.Memcache.Types.OpRequest
    -> GHC.Word.Word32
    -> Database.Memcache.Types.Version
    -> Database.Memcache.Types.OpRequest
    -> GHC.Word.Word32
    -> Database.Memcache.Types.Version
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U)><L,1*U(U)><S,1*U><L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ ww :: Database.Memcache.Types.OpRequest
                   ww1 :: GHC.Word.Word32
                   ww2 :: Database.Memcache.Types.Version
                   ww3 :: Database.Memcache.Types.OpRequest
                   ww4 :: GHC.Word.Word32
                   ww5 :: Database.Memcache.Types.Version ->
                 case Database.Memcache.Types.$fEqOpRequest_$c== ww ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Word.W32# a1 ->
                      case ww4 of wild2 { GHC.Word.W32# b1 ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# a1 b1) of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Word.$fEqWord64_$c== ww2 ww5 } } } }) -}
dc60357bc7699d88b9b1dac473300fa3
  $w$c==5 ::
    GHC.Prim.Word#
    -> Database.Memcache.Types.Delta
    -> Database.Memcache.Types.Expiration
    -> GHC.Prim.Word#
    -> Database.Memcache.Types.Delta
    -> Database.Memcache.Types.Expiration
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,1*U(U)><L,U><L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Word#
                   ww1 :: Database.Memcache.Types.Delta
                   ww2 :: Database.Memcache.Types.Expiration
                   ww3 :: GHC.Prim.Word#
                   ww4 :: Database.Memcache.Types.Delta
                   ww5 :: Database.Memcache.Types.Expiration ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# ww ww3) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Word.W64# a1 ->
                      case ww4 of wild2 { GHC.Word.W64# b1 ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# a1 b1) of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Word.$fEqWord32_$c== ww2 ww5 } } } }) -}
16974b410d4b28067cb09fc4c2894504
  $w$c==6 ::
    GHC.Prim.Word#
    -> Database.Memcache.Types.Expiration
    -> GHC.Prim.Word#
    -> Database.Memcache.Types.Expiration
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Word#
                   ww1 :: Database.Memcache.Types.Expiration
                   ww2 :: GHC.Prim.Word#
                   ww3 :: Database.Memcache.Types.Expiration ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Word.$fEqWord32_$c== ww1 ww3 }) -}
6c5a8f1f476066d0acf8842e8523fcc9
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> GHC.Base.String
    -> Database.Memcache.Types.Response
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U><L,U><L,1*U(1*U,U,U(U),1*U(U))>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Base.String
                   ww2 :: Database.Memcache.Types.Response ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = case ww2 of ww3 { Database.Memcache.Types.Res ww4 ww5 ww6 ww7 ->
                     Database.Memcache.Types.$w$cshowsPrec1 0 ww4 ww5 ww6 ww7 }
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Database.Memcache.Types.$fExceptionIncorrectResponse5
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Database.Memcache.Types.$fExceptionIncorrectResponse4
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows6
                             (GHC.Show.showLitString
                                ww1
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.shows6
                                   (GHC.Base.++
                                      @ GHC.Types.Char
                                      Database.Memcache.Types.$fExceptionIncorrectResponse3
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         Database.Memcache.Types.$fExceptionIncorrectResponse2
                                         (f (GHC.Base.++
                                               @ GHC.Types.Char
                                               Database.Memcache.Types.$fExceptionIncorrectResponse1
                                               x))))))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
208b90e08a9a90c5ed02f6dbe102b89f
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> Database.Memcache.Types.OpResponse
    -> Database.Memcache.Types.Status
    -> GHC.Word.Word32
    -> Database.Memcache.Types.Version
    -> GHC.Show.ShowS
  {- Arity: 5, Strictness: <L,U><L,1*U><L,U><L,U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: Database.Memcache.Types.OpResponse
                   ww2 :: Database.Memcache.Types.Status
                   ww3 :: GHC.Word.Word32
                   ww4 :: Database.Memcache.Types.Version ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                       Database.Memcache.Types.$fExceptionIncorrectResponse22
                       ww1
                 } in
                 let {
                   w1 :: GHC.Integer.Type.Integer
                   = case ww4 of wild { GHC.Word.W64# x# ->
                     let {
                       i# :: GHC.Prim.Int# = GHC.Prim.word2Int# x#
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# i# 0) of wild1 {
                       GHC.Types.False -> GHC.Integer.Type.wordToInteger x#
                       GHC.Types.True -> GHC.Integer.Type.smallInteger i# } }
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Database.Memcache.Types.$fExceptionIncorrectResponse21
                       (f (GHC.Base.++
                             @ GHC.Types.Char
                             Database.Memcache.Types.$fExceptionIncorrectResponse3
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Database.Memcache.Types.$fExceptionIncorrectResponse20
                                (Database.Memcache.Types.$w$cshowsPrec2
                                   ww2
                                   (GHC.Base.++
                                      @ GHC.Types.Char
                                      Database.Memcache.Types.$fExceptionIncorrectResponse3
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         Database.Memcache.Types.$fExceptionIncorrectResponse8
                                         (case ww3 of wild { GHC.Word.W32# x# ->
                                          let {
                                            ww5 :: GHC.Prim.Int# = GHC.Prim.word2Int# x#
                                          } in
                                          let {
                                            w :: GHC.Base.String
                                            = GHC.Base.++
                                                @ GHC.Types.Char
                                                Database.Memcache.Types.$fExceptionIncorrectResponse3
                                                (GHC.Base.++
                                                   @ GHC.Types.Char
                                                   Database.Memcache.Types.$fExceptionIncorrectResponse7
                                                   (case GHC.Show.$w$cshowsPrec1
                                                           0
                                                           w1
                                                           (GHC.Base.++
                                                              @ GHC.Types.Char
                                                              Database.Memcache.Types.$fExceptionIncorrectResponse1
                                                              x) of ww6 { (#,#) ww7 ww8 ->
                                                    GHC.Types.: @ GHC.Types.Char ww7 ww8 }))
                                          } in
                                          case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.<# ww5 0) of wild1 {
                                            GHC.Types.False
                                            -> case GHC.Show.$witos ww5 w of ww6 { (#,#) ww7 ww8 ->
                                               GHC.Types.: @ GHC.Types.Char ww7 ww8 }
                                            GHC.Types.True
                                            -> case GHC.Show.$witos ww5 w of ww6 { (#,#) ww7 ww8 ->
                                               GHC.Types.: @ GHC.Types.Char ww7 ww8 } } })))))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> \ x :: GHC.Base.String ->
                      GHC.Base.++
                        @ GHC.Types.Char
                        Database.Memcache.Types.$fExceptionIncorrectResponse6
                        (g x)
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Database.Memcache.Types.$fExceptionIncorrectResponse6
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x))) }) -}
f71e7ee459bd0dad4eebf489e8fa8742
  $w$cshowsPrec2 ::
    Database.Memcache.Types.Status
    -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: Database.Memcache.Types.Status
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   Database.Memcache.Types.NoError
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Database.Memcache.Types.$fExceptionIncorrectResponse19
                        w1
                   Database.Memcache.Types.ErrKeyNotFound
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Database.Memcache.Types.$fExceptionIncorrectResponse18
                        w1
                   Database.Memcache.Types.ErrKeyExists
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Database.Memcache.Types.$fExceptionIncorrectResponse17
                        w1
                   Database.Memcache.Types.ErrValueTooLarge
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Database.Memcache.Types.$fExceptionIncorrectResponse16
                        w1
                   Database.Memcache.Types.ErrInvalidArgs
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Database.Memcache.Types.$fExceptionIncorrectResponse15
                        w1
                   Database.Memcache.Types.ErrItemNotStored
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Database.Memcache.Types.$fExceptionIncorrectResponse14
                        w1
                   Database.Memcache.Types.ErrValueNonNumeric
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Database.Memcache.Types.$fExceptionIncorrectResponse13
                        w1
                   Database.Memcache.Types.ErrUnknownCommand
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Database.Memcache.Types.$fExceptionIncorrectResponse12
                        w1
                   Database.Memcache.Types.ErrOutOfMemory
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Database.Memcache.Types.$fExceptionIncorrectResponse11
                        w1
                   Database.Memcache.Types.SaslAuthFail
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Database.Memcache.Types.$fExceptionIncorrectResponse10
                        w1
                   Database.Memcache.Types.SaslAuthContinue
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Database.Memcache.Types.$fExceptionIncorrectResponse9
                        w1 }) -}
d7c2e2bad03dbbbdf8f5b24355a4f1c4
  $w$cshowsPrec3 ::
    GHC.Prim.Int#
    -> GHC.Base.String
    -> GHC.Base.Maybe Database.Memcache.Types.Header
    -> [GHC.Base.String]
    -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,U><L,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Base.String
                   ww2 :: GHC.Base.Maybe Database.Memcache.Types.Header
                   ww3 :: [GHC.Base.String] ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.$fShowMaybe_$cshowsPrec
                       @ Database.Memcache.Types.Header
                       Database.Memcache.Types.$fShowHeader
                       Database.Memcache.Types.$fExceptionIncorrectResponse22
                       ww2
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Database.Memcache.Types.$fExceptionProtocolError4
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Database.Memcache.Types.$fExceptionProtocolError3
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows6
                             (GHC.Show.showLitString
                                ww1
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.shows6
                                   (GHC.Base.++
                                      @ GHC.Types.Char
                                      Database.Memcache.Types.$fExceptionIncorrectResponse3
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         Database.Memcache.Types.$fExceptionProtocolError2
                                         (f (GHC.Base.++
                                               @ GHC.Types.Char
                                               Database.Memcache.Types.$fExceptionIncorrectResponse3
                                               (GHC.Base.++
                                                  @ GHC.Types.Char
                                                  Database.Memcache.Types.$fExceptionProtocolError1
                                                  (let {
                                                     s :: GHC.Base.String
                                                     = GHC.Base.++
                                                         @ GHC.Types.Char
                                                         Database.Memcache.Types.$fExceptionIncorrectResponse1
                                                         x
                                                   } in
                                                   case ww3 of wild {
                                                     [] -> GHC.CString.unpackAppendCString# "[]"# s
                                                     : x1 xs
                                                     -> GHC.Types.:
                                                          @ GHC.Types.Char
                                                          GHC.Show.showList__3
                                                          (GHC.Types.:
                                                             @ GHC.Types.Char
                                                             GHC.Show.shows6
                                                             (GHC.Show.showLitString
                                                                x1
                                                                (GHC.Types.:
                                                                   @ GHC.Types.Char
                                                                   GHC.Show.shows6
                                                                   (let {
                                                                      lvl56 :: [GHC.Types.Char]
                                                                      = GHC.Types.:
                                                                          @ GHC.Types.Char
                                                                          GHC.Show.showList__2
                                                                          s
                                                                    } in
                                                                    letrec {
                                                                      showl :: [[GHC.Types.Char]]
                                                                               -> [GHC.Types.Char]
                                                                        {- Arity: 1,
                                                                           Strictness: <S,1*U> -}
                                                                      = \ ds2 :: [[GHC.Types.Char]] ->
                                                                        case ds2 of wild1 {
                                                                          [] -> lvl56
                                                                          : y ys
                                                                          -> GHC.Types.:
                                                                               @ GHC.Types.Char
                                                                               GHC.Show.showList__1
                                                                               (GHC.Types.:
                                                                                  @ GHC.Types.Char
                                                                                  GHC.Show.shows6
                                                                                  (GHC.Show.showLitString
                                                                                     y
                                                                                     (GHC.Types.:
                                                                                        @ GHC.Types.Char
                                                                                        GHC.Show.shows6
                                                                                        (showl
                                                                                           ys)))) }
                                                                    } in
                                                                    showl xs)))) }))))))))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
733e044a842a3fa7f6220cf1f9e193a4
  $w$cshowsPrec4 ::
    GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Word.Word16
    -> GHC.Word.Word8
    -> Database.Memcache.Types.Status
    -> GHC.Word.Word32
    -> GHC.Word.Word32
    -> Database.Memcache.Types.Version
    -> GHC.Show.ShowS
  {- Arity: 8,
     Strictness: <L,U><L,U(U)><L,U(U)><L,U(U)><L,U><L,U(U)><L,U(U)><L,1*U(U)>,
     Inline: [0] -}
4e8e1443f74641bb656eab6eb306da09
  $w$cshowsPrec5 ::
    GHC.Prim.Int#
    -> Database.Memcache.Types.OpRequest
    -> GHC.Word.Word32
    -> Database.Memcache.Types.Version
    -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,U><L,1*U><L,U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: Database.Memcache.Types.OpRequest
                   ww2 :: GHC.Word.Word32
                   ww3 :: Database.Memcache.Types.Version ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = Database.Memcache.Types.$fShowOpRequest_$cshowsPrec
                       Database.Memcache.Types.$fExceptionIncorrectResponse22
                       ww1
                 } in
                 let {
                   w1 :: GHC.Integer.Type.Integer
                   = case ww3 of wild { GHC.Word.W64# x# ->
                     let {
                       i# :: GHC.Prim.Int# = GHC.Prim.word2Int# x#
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# i# 0) of wild1 {
                       GHC.Types.False -> GHC.Integer.Type.wordToInteger x#
                       GHC.Types.True -> GHC.Integer.Type.smallInteger i# } }
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Database.Memcache.Types.$fShowRequest5
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Database.Memcache.Types.$fShowRequest4
                          (f (GHC.Base.++
                                @ GHC.Types.Char
                                Database.Memcache.Types.$fExceptionIncorrectResponse3
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   Database.Memcache.Types.$fShowRequest3
                                   (case ww2 of wild { GHC.Word.W32# x# ->
                                    let {
                                      ww4 :: GHC.Prim.Int# = GHC.Prim.word2Int# x#
                                    } in
                                    let {
                                      w :: GHC.Base.String
                                      = GHC.Base.++
                                          @ GHC.Types.Char
                                          Database.Memcache.Types.$fExceptionIncorrectResponse3
                                          (GHC.Base.++
                                             @ GHC.Types.Char
                                             Database.Memcache.Types.$fShowRequest2
                                             (case GHC.Show.$w$cshowsPrec1
                                                     0
                                                     w1
                                                     (GHC.Base.++
                                                        @ GHC.Types.Char
                                                        Database.Memcache.Types.$fExceptionIncorrectResponse1
                                                        x) of ww5 { (#,#) ww6 ww7 ->
                                              GHC.Types.: @ GHC.Types.Char ww6 ww7 }))
                                    } in
                                    case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.<# ww4 0) of wild1 {
                                      GHC.Types.False
                                      -> case GHC.Show.$witos ww4 w of ww5 { (#,#) ww6 ww7 ->
                                         GHC.Types.: @ GHC.Types.Char ww6 ww7 }
                                      GHC.Types.True
                                      -> case GHC.Show.$witos ww4 w of ww5 { (#,#) ww6 ww7 ->
                                         GHC.Types.: @ GHC.Types.Char ww6 ww7 } } })))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
35adea6f9c0b60fb3c876978a28b09db
  $w$cshowsPrec6 ::
    GHC.Prim.Int#
    -> Database.Memcache.Types.Initial
    -> Database.Memcache.Types.Delta
    -> Database.Memcache.Types.Expiration
    -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,U><L,1*U(U)><L,1*U(U)><L,U(U)>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: Database.Memcache.Types.Initial
                   ww2 :: Database.Memcache.Types.Delta
                   ww3 :: Database.Memcache.Types.Expiration ->
                 let {
                   w1 :: GHC.Integer.Type.Integer
                   = case ww1 of wild { GHC.Word.W64# x# ->
                     let {
                       i# :: GHC.Prim.Int# = GHC.Prim.word2Int# x#
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# i# 0) of wild1 {
                       GHC.Types.False -> GHC.Integer.Type.wordToInteger x#
                       GHC.Types.True -> GHC.Integer.Type.smallInteger i# } }
                 } in
                 let {
                   w2 :: GHC.Integer.Type.Integer
                   = case ww2 of wild { GHC.Word.W64# x# ->
                     let {
                       i# :: GHC.Prim.Int# = GHC.Prim.word2Int# x#
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# i# 0) of wild1 {
                       GHC.Types.False -> GHC.Integer.Type.wordToInteger x#
                       GHC.Types.True -> GHC.Integer.Type.smallInteger i# } }
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Database.Memcache.Types.$fShowSEIncr2
                       (case GHC.Show.$w$cshowsPrec1
                               11
                               w1
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showSpace1
                                  (case GHC.Show.$w$cshowsPrec1
                                          11
                                          w2
                                          (GHC.Types.:
                                             @ GHC.Types.Char
                                             GHC.Show.showSpace1
                                             (case ww3 of wild { GHC.Word.W32# x# ->
                                              case GHC.Show.$wshowSignedInt
                                                     11
                                                     (GHC.Prim.word2Int# x#)
                                                     x of ww4 { (#,#) ww5 ww6 ->
                                              GHC.Types.:
                                                @ GHC.Types.Char
                                                ww5
                                                ww6 } })) of ww4 { (#,#) ww5 ww6 ->
                                   GHC.Types.:
                                     @ GHC.Types.Char
                                     ww5
                                     ww6 })) of ww4 { (#,#) ww5 ww6 ->
                        GHC.Types.: @ GHC.Types.Char ww5 ww6 })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
92629121fc4a65dd76a3c01c2554fd96
  $w$cshowsPrec7 ::
    GHC.Prim.Int#
    -> Database.Memcache.Types.Flags
    -> Database.Memcache.Types.Expiration
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,1*U(U)><L,1*U(U)><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: Database.Memcache.Types.Flags
                   ww2 :: Database.Memcache.Types.Expiration
                   w :: GHC.Base.String ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     case ww1 of wild { GHC.Word.W32# x# ->
                     case GHC.Show.$wshowSignedInt
                            11
                            (GHC.Prim.word2Int# x#)
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (case ww2 of wild1 { GHC.Word.W32# x#1 ->
                                case GHC.Show.$wshowSignedInt
                                       11
                                       (GHC.Prim.word2Int# x#1)
                                       x of ww4 { (#,#) ww5 ww6 ->
                                GHC.Types.:
                                  @ GHC.Types.Char
                                  ww5
                                  ww6 } })) of ww4 { (#,#) ww5 ww6 ->
                     GHC.Types.: @ GHC.Types.Char ww5 ww6 } }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Database.Memcache.Types.$fShowSESet2
                        (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Database.Memcache.Types.$fShowSESet2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
f6831439551e274e5761438ac49e3f39
  $w$cshowsPrec8 ::
    GHC.Prim.Int#
    -> Database.Memcache.Types.Expiration
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,1*U(U)><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: Database.Memcache.Types.Expiration
                   w :: GHC.Base.String ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Database.Memcache.Types.$fShowSETouch2
                       (case ww1 of wild { GHC.Word.W32# x# ->
                        case GHC.Show.$wshowSignedInt
                               11
                               (GHC.Prim.word2Int# x#)
                               x of ww4 { (#,#) ww5 ww6 ->
                        GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w)) }) -}
8ea464ac72c68def1a36ff30f351146e
  data Authentication
    = Auth {username :: !Database.Memcache.Types.Username,
            password :: !Database.Memcache.Types.Password}
    | NoAuth
08f5e98b33234ca73b9435764a872254
  type Delta = GHC.Word.Word64
eee7d8eb89d1f5e08ca98b4e528cdfa6
  type Expiration = GHC.Word.Word32
283e1154d146a27ab3d1d3cb307d40ca
  type Extras = Data.ByteString.Internal.ByteString
cfdbf9ee7e2e6dd714d9bba65e0caaea
  type Flags = GHC.Word.Word32
47fc59a5a05b162f38cd94795863eb39
  data Header
    = Header {op :: GHC.Word.Word8,
              keyLen :: GHC.Word.Word16,
              extraLen :: GHC.Word.Word8,
              status :: Database.Memcache.Types.Status,
              bodyLen :: GHC.Word.Word32,
              opaque :: GHC.Word.Word32,
              cas :: Database.Memcache.Types.Version}
51406e114fcd5f8f3a7d1e46ab07ef3f
  data IncorrectResponse
    = IncorrectResponse {increspMessage :: GHC.Base.String,
                         increspActual :: Database.Memcache.Types.Response}
fe5c2baac87c95b22c30e272241ceb7f
  type Initial = GHC.Word.Word64
8177c343328e32152fc3982cf198a5bf
  data K = NoKey | IncludeKey
    Promotable
b20ddb86e07e28f2bf61f4be3964ff74
  type Key = Data.ByteString.Internal.ByteString
c5b4f9fcb9c0519776d09b0b646373b0
  data OpRequest
    = ReqGet Database.Memcache.Types.Q
             Database.Memcache.Types.K
             Database.Memcache.Types.Key
    | ReqSet Database.Memcache.Types.Q
             Database.Memcache.Types.Key
             Database.Memcache.Types.Value
             Database.Memcache.Types.SESet
    | ReqAdd Database.Memcache.Types.Q
             Database.Memcache.Types.Key
             Database.Memcache.Types.Value
             Database.Memcache.Types.SESet
    | ReqReplace Database.Memcache.Types.Q
                 Database.Memcache.Types.Key
                 Database.Memcache.Types.Value
                 Database.Memcache.Types.SESet
    | ReqDelete Database.Memcache.Types.Q Database.Memcache.Types.Key
    | ReqIncrement Database.Memcache.Types.Q
                   Database.Memcache.Types.Key
                   Database.Memcache.Types.SEIncr
    | ReqDecrement Database.Memcache.Types.Q
                   Database.Memcache.Types.Key
                   Database.Memcache.Types.SEIncr
    | ReqAppend Database.Memcache.Types.Q
                Database.Memcache.Types.Key
                Database.Memcache.Types.Value
    | ReqPrepend Database.Memcache.Types.Q
                 Database.Memcache.Types.Key
                 Database.Memcache.Types.Value
    | ReqTouch Database.Memcache.Types.Key
               Database.Memcache.Types.SETouch
    | ReqGAT Database.Memcache.Types.Q
             Database.Memcache.Types.K
             Database.Memcache.Types.Key
             Database.Memcache.Types.SETouch
    | ReqFlush Database.Memcache.Types.Q
               (GHC.Base.Maybe Database.Memcache.Types.SETouch)
    | ReqNoop
    | ReqVersion
    | ReqStat (GHC.Base.Maybe Database.Memcache.Types.Key)
    | ReqQuit Database.Memcache.Types.Q
    | ReqSASLList
    | ReqSASLStart Database.Memcache.Types.Key
                   Database.Memcache.Types.Value
    | ReqSASLStep Database.Memcache.Types.Key
                  Database.Memcache.Types.Value
cf3a3a0f90f9c2f75ebba016c93bc71e
  data OpResponse
    = ResGet Database.Memcache.Types.Q
             Database.Memcache.Types.Value
             Database.Memcache.Types.Flags
    | ResGetK Database.Memcache.Types.Q
              Database.Memcache.Types.Key
              Database.Memcache.Types.Value
              Database.Memcache.Types.Flags
    | ResSet Database.Memcache.Types.Q
    | ResAdd Database.Memcache.Types.Q
    | ResReplace Database.Memcache.Types.Q
    | ResDelete Database.Memcache.Types.Q
    | ResIncrement Database.Memcache.Types.Q GHC.Word.Word64
    | ResDecrement Database.Memcache.Types.Q GHC.Word.Word64
    | ResAppend Database.Memcache.Types.Q
    | ResPrepend Database.Memcache.Types.Q
    | ResTouch
    | ResGAT Database.Memcache.Types.Q
             Database.Memcache.Types.Value
             Database.Memcache.Types.Flags
    | ResGATK Database.Memcache.Types.Q
              Database.Memcache.Types.Key
              Database.Memcache.Types.Value
              Database.Memcache.Types.Flags
    | ResFlush Database.Memcache.Types.Q
    | ResNoop
    | ResVersion Database.Memcache.Types.Value
    | ResStat Database.Memcache.Types.Key Database.Memcache.Types.Value
    | ResQuit Database.Memcache.Types.Q
    | ResSASLList Database.Memcache.Types.Value
    | ResSASLStart
    | ResSASLStep
7121270c1aa14355cd6bfae6b9012f71
  type Password = Data.ByteString.Internal.ByteString
9fa9327ab0e3d012791f9397a05b9d72
  data ProtocolError
    = ProtocolError {protocolMessage :: GHC.Base.String,
                     protocolHeader :: GHC.Base.Maybe Database.Memcache.Types.Header,
                     protocolParams :: [GHC.Base.String]}
0cbe00637e51cfb9aa1e8b4a80a1f5a2
  data Q = Loud | Quiet
    Promotable
ea22f4eb312eac51b3d37628818241fd
  data Request
    = Req {reqOp :: Database.Memcache.Types.OpRequest,
           reqOpaque :: GHC.Word.Word32,
           reqCas :: Database.Memcache.Types.Version}
900e0e3188debaef4afb10615d76a76e
  data Response
    = Res {resOp :: Database.Memcache.Types.OpResponse,
           resStatus :: Database.Memcache.Types.Status,
           resOpaque :: GHC.Word.Word32,
           resCas :: Database.Memcache.Types.Version}
59b33ee12c2a21fcfcee5480494574f4
  data SEIncr
    = SEIncr Database.Memcache.Types.Initial
             Database.Memcache.Types.Delta
             Database.Memcache.Types.Expiration
00b1c94659decc80088f37e35b25a15d
  data SESet
    = SESet Database.Memcache.Types.Flags
            Database.Memcache.Types.Expiration
e6d91a6d1dd224a5ee7a3f24ab184527
  data SETouch = SETouch Database.Memcache.Types.Expiration
f71e7ee459bd0dad4eebf489e8fa8742
  data Status
    = NoError
    | ErrKeyNotFound
    | ErrKeyExists
    | ErrValueTooLarge
    | ErrInvalidArgs
    | ErrItemNotStored
    | ErrValueNonNumeric
    | ErrUnknownCommand
    | ErrOutOfMemory
    | SaslAuthFail
    | SaslAuthContinue
    Promotable
638424c217dded13aadf320cefed8218
  type Username = Data.ByteString.Internal.ByteString
07b472038339627c113b5956ea6bb2a4
  type Value = Data.ByteString.Internal.ByteString
58806aff1405372220ddeb47e508949f
  type Version = GHC.Word.Word64
f325570cfae82ef32daaf31c40135356
  bodyLen :: Database.Memcache.Types.Header -> GHC.Word.Word32
  RecSel Database.Memcache.Types.Header
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLSLL),1*U(A,A,A,A,1*U(U),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.Header ->
                 case ds of wild { Database.Memcache.Types.Header ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds5 }) -}
875d01859f0948872599069a9f6569a1
  cas ::
    Database.Memcache.Types.Header -> Database.Memcache.Types.Version
  RecSel Database.Memcache.Types.Header
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLS),1*U(A,A,A,A,A,A,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.Header ->
                 case ds of wild { Database.Memcache.Types.Header ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds7 }) -}
5d795e57cb58c7b51e50a20ade00edba
  emptyReq :: Database.Memcache.Types.Request
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Database.Memcache.Types.Req
                   Database.Memcache.Types.ReqNoop
                   Database.Memcache.Types.emptyReq2
                   Database.Memcache.Types.emptyReq1) -}
ed2e849b6b093a1e6bb8d0513c36e198
  emptyReq1 :: GHC.Word.Word64
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W64# __word 0) -}
1bdb47227b0f954156acf5a21eb38d0a
  emptyReq2 :: GHC.Word.Word32
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W32# __word 0) -}
7b188eb58e9098d7769dffe47cbeaba2
  extraLen :: Database.Memcache.Types.Header -> GHC.Word.Word8
  RecSel Database.Memcache.Types.Header
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLLLL),1*U(A,A,1*U(U),A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.Header ->
                 case ds of wild { Database.Memcache.Types.Header ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds3 }) -}
880530c0f85397801aa74b6cc48d8582
  increspActual ::
    Database.Memcache.Types.IncorrectResponse
    -> Database.Memcache.Types.Response
  RecSel Database.Memcache.Types.IncorrectResponse
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U,U,U,U))>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.IncorrectResponse ->
                 case ds of wild { Database.Memcache.Types.IncorrectResponse ds1 ds2 ->
                 ds2 }) -}
2ea50ec0b67dbac5f82f268f6b350f20
  increspMessage ::
    Database.Memcache.Types.IncorrectResponse -> GHC.Base.String
  RecSel Database.Memcache.Types.IncorrectResponse
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.IncorrectResponse ->
                 case ds of wild { Database.Memcache.Types.IncorrectResponse ds1 ds2 ->
                 ds1 }) -}
75a39ac321a9b695d5dd9e168b68e8a3
  keyLen :: Database.Memcache.Types.Header -> GHC.Word.Word16
  RecSel Database.Memcache.Types.Header
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLLL),1*U(A,1*U(U),A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.Header ->
                 case ds of wild { Database.Memcache.Types.Header ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds2 }) -}
e650c0dbad52d1aa03fa1f9b34814921
  mEMCACHE_HEADER_SIZE :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 24) -}
a7c978dffd1e022beb3721a5537c84e0
  op :: Database.Memcache.Types.Header -> GHC.Word.Word8
  RecSel Database.Memcache.Types.Header
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLLLL),1*U(1*U(U),A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.Header ->
                 case ds of wild { Database.Memcache.Types.Header ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds1 }) -}
e8fc55b69841df478be4328601821e7d
  opaque :: Database.Memcache.Types.Header -> GHC.Word.Word32
  RecSel Database.Memcache.Types.Header
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLSL),1*U(A,A,A,A,A,1*U(U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.Header ->
                 case ds of wild { Database.Memcache.Types.Header ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds6 }) -}
fea82a05786f16436b3f439f2275017f
  password ::
    Database.Memcache.Types.Authentication
    -> Database.Memcache.Types.Password
  RecSel Database.Memcache.Types.Authentication
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.Authentication ->
                 case ds of wild {
                   Database.Memcache.Types.Auth ds1 ds2 -> ds2
                   Database.Memcache.Types.NoAuth
                   -> Database.Memcache.Types.password1 }) -}
5948437f908fb5783e7507a43f489462
  password1 :: Database.Memcache.Types.Password
  {- Strictness: b -}
5e8093f874d940f659f981dabb0c7d8d
  protocolHeader ::
    Database.Memcache.Types.ProtocolError
    -> GHC.Base.Maybe Database.Memcache.Types.Header
  RecSel Database.Memcache.Types.ProtocolError
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.ProtocolError ->
                 case ds of wild { Database.Memcache.Types.ProtocolError ds1 ds2 ds3 ->
                 ds2 }) -}
bd8e737e00a44540c2c174e145a1de17
  protocolMessage ::
    Database.Memcache.Types.ProtocolError -> GHC.Base.String
  RecSel Database.Memcache.Types.ProtocolError
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.ProtocolError ->
                 case ds of wild { Database.Memcache.Types.ProtocolError ds1 ds2 ds3 ->
                 ds1 }) -}
0691dee6336cdf72ef0c0f094faf5595
  protocolParams ::
    Database.Memcache.Types.ProtocolError -> [GHC.Base.String]
  RecSel Database.Memcache.Types.ProtocolError
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.ProtocolError ->
                 case ds of wild { Database.Memcache.Types.ProtocolError ds1 ds2 ds3 ->
                 ds3 }) -}
2ee23fd42bcc376c3d6a0d0fe4a933fa
  reqCas ::
    Database.Memcache.Types.Request -> Database.Memcache.Types.Version
  RecSel Database.Memcache.Types.Request
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.Request ->
                 case ds of wild { Database.Memcache.Types.Req ds1 ds2 ds3 ->
                 ds3 }) -}
0186d62f830ab3c946d7b95ffedfda3b
  reqOp ::
    Database.Memcache.Types.Request
    -> Database.Memcache.Types.OpRequest
  RecSel Database.Memcache.Types.Request
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.Request ->
                 case ds of wild { Database.Memcache.Types.Req ds1 ds2 ds3 ->
                 ds1 }) -}
707c4da822ba4c38439009083124b9d6
  reqOpaque :: Database.Memcache.Types.Request -> GHC.Word.Word32
  RecSel Database.Memcache.Types.Request
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U(U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.Request ->
                 case ds of wild { Database.Memcache.Types.Req ds1 ds2 ds3 ->
                 ds2 }) -}
c2e2db5893b041ff735965fe41df879a
  resCas ::
    Database.Memcache.Types.Response -> Database.Memcache.Types.Version
  RecSel Database.Memcache.Types.Response
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(A,A,A,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.Response ->
                 case ds of wild { Database.Memcache.Types.Res ds1 ds2 ds3 ds4 ->
                 ds4 }) -}
ab0836dc5e0d6b259d4d7b4ced85fd46
  resOp ::
    Database.Memcache.Types.Response
    -> Database.Memcache.Types.OpResponse
  RecSel Database.Memcache.Types.Response
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLLL),1*U(1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.Response ->
                 case ds of wild { Database.Memcache.Types.Res ds1 ds2 ds3 ds4 ->
                 ds1 }) -}
09b4e76c4f41ba4dc555dfb3a0d1a16c
  resOpaque :: Database.Memcache.Types.Response -> GHC.Word.Word32
  RecSel Database.Memcache.Types.Response
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSL),1*U(A,A,1*U(U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.Response ->
                 case ds of wild { Database.Memcache.Types.Res ds1 ds2 ds3 ds4 ->
                 ds3 }) -}
97abb3ce97d2701aa229b493f0acf5c5
  resStatus ::
    Database.Memcache.Types.Response -> Database.Memcache.Types.Status
  RecSel Database.Memcache.Types.Response
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSLL),1*U(A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.Response ->
                 case ds of wild { Database.Memcache.Types.Res ds1 ds2 ds3 ds4 ->
                 ds2 }) -}
64b92e9124beaf0284143e02011645b8
  status ::
    Database.Memcache.Types.Header -> Database.Memcache.Types.Status
  RecSel Database.Memcache.Types.Header
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLLL),1*U(A,A,A,1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.Header ->
                 case ds of wild { Database.Memcache.Types.Header ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds4 }) -}
4cc4f32fe77b70fee1c117fa7a375c8c
  username ::
    Database.Memcache.Types.Authentication
    -> Database.Memcache.Types.Username
  RecSel Database.Memcache.Types.Authentication
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Database.Memcache.Types.Authentication ->
                 case ds of wild {
                   Database.Memcache.Types.Auth ds1 ds2 -> ds1
                   Database.Memcache.Types.NoAuth
                   -> Database.Memcache.Types.username1 }) -}
ae06fdac7b4026af6ccbd089d97aa86d
  username1 :: Database.Memcache.Types.Username
  {- Strictness: b -}
instance GHC.Classes.Eq [Database.Memcache.Types.Authentication]
  = Database.Memcache.Types.$fEqAuthentication
instance GHC.Classes.Eq [Database.Memcache.Types.Header]
  = Database.Memcache.Types.$fEqHeader
instance GHC.Classes.Eq [Database.Memcache.Types.IncorrectResponse]
  = Database.Memcache.Types.$fEqIncorrectResponse
instance GHC.Classes.Eq [Database.Memcache.Types.K]
  = Database.Memcache.Types.$fEqK
instance GHC.Classes.Eq [Database.Memcache.Types.OpRequest]
  = Database.Memcache.Types.$fEqOpRequest
instance GHC.Classes.Eq [Database.Memcache.Types.OpResponse]
  = Database.Memcache.Types.$fEqOpResponse
instance GHC.Classes.Eq [Database.Memcache.Types.ProtocolError]
  = Database.Memcache.Types.$fEqProtocolError
instance GHC.Classes.Eq [Database.Memcache.Types.Q]
  = Database.Memcache.Types.$fEqQ
instance GHC.Classes.Eq [Database.Memcache.Types.Request]
  = Database.Memcache.Types.$fEqRequest
instance GHC.Classes.Eq [Database.Memcache.Types.Response]
  = Database.Memcache.Types.$fEqResponse
instance GHC.Classes.Eq [Database.Memcache.Types.SEIncr]
  = Database.Memcache.Types.$fEqSEIncr
instance GHC.Classes.Eq [Database.Memcache.Types.SESet]
  = Database.Memcache.Types.$fEqSESet
instance GHC.Classes.Eq [Database.Memcache.Types.SETouch]
  = Database.Memcache.Types.$fEqSETouch
instance GHC.Classes.Eq [Database.Memcache.Types.Status]
  = Database.Memcache.Types.$fEqStatus
instance GHC.Exception.Exception [Database.Memcache.Types.IncorrectResponse]
  = Database.Memcache.Types.$fExceptionIncorrectResponse
instance GHC.Exception.Exception [Database.Memcache.Types.ProtocolError]
  = Database.Memcache.Types.$fExceptionProtocolError
instance GHC.Show.Show [Database.Memcache.Types.Authentication]
  = Database.Memcache.Types.$fShowAuthentication
instance GHC.Show.Show [Database.Memcache.Types.Header]
  = Database.Memcache.Types.$fShowHeader
instance GHC.Show.Show [Database.Memcache.Types.IncorrectResponse]
  = Database.Memcache.Types.$fShowIncorrectResponse
instance GHC.Show.Show [Database.Memcache.Types.K]
  = Database.Memcache.Types.$fShowK
instance GHC.Show.Show [Database.Memcache.Types.OpRequest]
  = Database.Memcache.Types.$fShowOpRequest
instance GHC.Show.Show [Database.Memcache.Types.OpResponse]
  = Database.Memcache.Types.$fShowOpResponse
instance GHC.Show.Show [Database.Memcache.Types.ProtocolError]
  = Database.Memcache.Types.$fShowProtocolError
instance GHC.Show.Show [Database.Memcache.Types.Q]
  = Database.Memcache.Types.$fShowQ
instance GHC.Show.Show [Database.Memcache.Types.Request]
  = Database.Memcache.Types.$fShowRequest
instance GHC.Show.Show [Database.Memcache.Types.Response]
  = Database.Memcache.Types.$fShowResponse
instance GHC.Show.Show [Database.Memcache.Types.SEIncr]
  = Database.Memcache.Types.$fShowSEIncr
instance GHC.Show.Show [Database.Memcache.Types.SESet]
  = Database.Memcache.Types.$fShowSESet
instance GHC.Show.Show [Database.Memcache.Types.SETouch]
  = Database.Memcache.Types.$fShowSETouch
instance GHC.Show.Show [Database.Memcache.Types.Status]
  = Database.Memcache.Types.$fShowStatus
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

