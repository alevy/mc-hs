
==================== FINAL INTERFACE ====================
2016-02-25 11:05:44.229138 UTC

interface memca_3Z8qUpsEDiC53dYw3oq6HZ:Database.Memcache.Protocol 7103
  interface hash: 93f3be69ceeaecd7453fd5feb4e11978
  ABI hash: bc4fd50b2fed65552f36d5a5e2f07c5a
  export-list hash: 969edc630ff2215978f3cd21fe44e77c
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 75b7ebcfce8111bf9fdcb80dfc018487
  sig of: Nothing
  used TH splices: False
  where
exports:
  Database.Memcache.Protocol.add
  Database.Memcache.Protocol.append
  Database.Memcache.Protocol.decrement
  Database.Memcache.Protocol.delete
  Database.Memcache.Protocol.flush
  Database.Memcache.Protocol.gat
  Database.Memcache.Protocol.get
  Database.Memcache.Protocol.increment
  Database.Memcache.Protocol.noop
  Database.Memcache.Protocol.prepend
  Database.Memcache.Protocol.quit
  Database.Memcache.Protocol.replace
  Database.Memcache.Protocol.set
  Database.Memcache.Protocol.set'
  Database.Memcache.Protocol.stats
  Database.Memcache.Protocol.touch
  Database.Memcache.Protocol.version
  Database.Memcache.Protocol.StatResults
module dependencies: Database.Memcache.Errors
                     Database.Memcache.SASL Database.Memcache.Server
                     Database.Memcache.Types Database.Memcache.Wire
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0 binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi
                      blaze-builder-0.4.0.1@blaze_GoSGMrJXTmeEBoF3sgxwrM
                      bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6
                      containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      hashable-1.2.4.0@hasha_8GjadD03dR57AKCJdr90LD integer-gmp-1.0.0.0
                      monad-control-1.0.0.5@monad_0V0Z5ArSaI68lPP0A0bpaP
                      network-2.6.2.1@netwo_A6pE0dLgMEk2GtUa1JtTJQ
                      primitive-0.6.1.0@primi_EphY2c7CCxSCBKjAN0YTR3
                      resource-pool-0.2.3.2@resou_IPeOzEJlakZ6oei4wPpERj
                      stm-2.4.4.1@stm_EyxFXFfnfY05IrjGaqCxeD
                      text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI
                      time-1.5.0.1@time_FTheb6LSxyX1UABIbBXRfn
                      transformers-base-0.4.4@trans_74WedXVmfaHHDJItmBRTVp
                      transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF
                      vector-0.11.0.0@vecto_LmZ3LQW4ivu8MsQuVgukln
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString.Builder
         hashable-1.2.4.0@hasha_8GjadD03dR57AKCJdr90LD:Data.Hashable.Generic
         network-2.6.2.1@netwo_A6pE0dLgMEk2GtUa1JtTJQ:Network.Socket
         network-2.6.2.1@netwo_A6pE0dLgMEk2GtUa1JtTJQ:Network.Socket.Types
         stm-2.4.4.1@stm_EyxFXFfnfY05IrjGaqCxeD:Control.Monad.STM
         text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI:Data.Text
         text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI:Data.Text.Lazy
         text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI:Data.Text.Show
         transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.Error
         vector-0.11.0.0@vecto_LmZ3LQW4ivu8MsQuVgukln:Data.Vector.Fusion.Bundle
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.IntMap.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.IntSet.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Sequence
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
                         monad-control-1.0.0.5@monad_0V0Z5ArSaI68lPP0A0bpaP:Control.Monad.Trans.Control
                         primitive-0.6.1.0@primi_EphY2c7CCxSCBKjAN0YTR3:Control.Monad.Primitive
                         text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI:Data.Text
                         text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI:Data.Text.Lazy
                         vector-0.11.0.0@vecto_LmZ3LQW4ivu8MsQuVgukln:Data.Vector
import  -/  base-4.8.2.0:Control.Exception e9090e246fba030faecf7b81b3e8e320
import  -/  base-4.8.2.0:Control.Exception.Base b99410eaf0cc6bb119b1d45a497c1b10
import  -/  base-4.8.2.0:Control.Monad 480c5067477275068c9b98be08410df9
import  -/  base-4.8.2.0:Data.Word ec8deb535202352cc8b509b14004bcbd
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Exception 18c46fe9c5c0c3a120035f264ef32d41
import  -/  base-4.8.2.0:GHC.Word 10dc88543d98000abab9695a1019767d
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString db2e56635ed30ff269e1492b64605a38
import  -/  bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString.Internal b99858e89f19feddd3dcb9e9d523065e
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  Database.Memcache.Errors f8f7d6f9d99620e8545ec26851698f07
  exports: a3cc4d4a1d68c42bd6d48dd70317f453
  throwIncorrectRes f478ead1e2d71f13c62ecfb231779cc1
  throwStatus e89ca9d8ac3aeb028ace78d7f4e97e7e
import  -/  Database.Memcache.Server 7935f876b3050e69916f6708b334cea7
  exports: 4b4f03728680b2d70aa3fff298403484
  Server 0e49d261e0c691d9caf4b6f494d266da
  close 4e137c4fa0a57f83268e11aaca402944
  sendRecv e094f0841f992b5efa60eac61471d6bb
  withSocket 1bc87112c88d735c7644881c086d9400
import  -/  Database.Memcache.Types 1ca9931bda88d72b9d7d6f6ee335bcb6
  exports: b2f7697915662eeadb8e65de002e666b
  Delta 08f5e98b33234ca73b9435764a872254
  ErrKeyExists 5231ffa983e267e4412dffb55a559f27
  ErrKeyNotFound 04a096dd54702e9cc95efe88e1001002
  Expiration eee7d8eb89d1f5e08ca98b4e528cdfa6
  Flags cfdbf9ee7e2e6dd714d9bba65e0caaea
  Initial fe5c2baac87c95b22c30e272241ceb7f
  Key b20ddb86e07e28f2bf61f4be3964ff74
  Loud c7c2c72b46cf295508516503158127bf
  NoError ec1b5aef072751e44f93fec6d161ed3d
  NoKey 70097a776b034a795b64a5853343a01c
  ReqAdd 295d2a59c576b254ca89113c75c0389d
  ReqAppend 2bbc92be0589cbd5f75ca9fc258bb2c6
  ReqDecrement 9f6bd46c2fe50f6c10b0c2259dac7e7d
  ReqDelete f065caf591624cb83d7c974927c2aabc
  ReqFlush 4f97b1e2923a81539d81ccfb6b8cdb73
  ReqGAT 49eccfcc2c4612057ec291c44340a660
  ReqGet 7bf602816afc4e8d5ca28240a52393b7
  ReqIncrement c6ecdf70ae4c314dcb0d72f6fcd56272
  ReqNoop f6e8d1d5e82f5d5e093b35406776f721
  ReqPrepend 86ede568ed5be269ad64a8a76f538838
  ReqQuit 23b3f1cee88752a12d200812c7c55e86
  ReqReplace 54700e66733fdf4ecca42d6bed5d5b99
  ReqSet 5e3099a7ea74214d38fe2429afac663a
  ReqStat aa59e97a53867ff8e6843708dbd523d2
  ReqTouch 7fc82e70f82f8f18d3551da32a2b170f
  ReqVersion b1e2505a55b2ba608195b2c4590be0d1
  ResAdd fee7d37cbdbfa94466f18a7c1e9cad2a
  ResAppend 166b3d6d5fab7e177da446dd9fa5ba46
  ResDecrement a679411c0e6bfa1232ba3a8dfaa3622b
  ResDelete 0bd431d7db122b394b69ec9d79cff852
  ResFlush 4d2f1bbe818b09f1d2092db4c4c4a8f5
  ResGAT 51f25446742122ba4953bb31a1b1bc72
  ResGet ef4688130b659552e0bf40d15c2d1e69
  ResIncrement a05bf234f22688b10eb5f53601c2632c
  ResNoop b7478055431275b4d2119be9edf4c351
  ResPrepend c2f7fc98a7d9f306ee5d85d17f1ec6d3
  ResQuit c31b44d4fdb991cee7afb23d7307734b
  ResReplace 1173c16c084b26355e46a01c407abaca
  ResSet 909bce851d49a27818a9510a162da063
  ResStat 905037257369caa5b4b1c97c5e69bbf2
  ResTouch 8955d2e06bf035c9c1d214228e4a77b6
  ResVersion d95a13a4e704e7bacff9adcdf9345278
  SEIncr 7b4cc81ff71b0954880e71f07e810a98
  SESet 536b4acf68c4663d3ec6bb3fcda5c399
  SETouch dc0f9fefa062bb0e4bee28624a801dd8
  Value 07b472038339627c113b5956ea6bb2a4
  Version 58806aff1405372220ddeb47e508949f
  emptyReq 5d795e57cb58c7b51e50a20ade00edba
  reqCas 2ee23fd42bcc376c3d6a0d0fe4a933fa
  reqOp 0186d62f830ab3c946d7b95ffedfda3b
  resCas c2e2db5893b041ff735965fe41df879a
  resOp ab0836dc5e0d6b259d4d7b4ced85fd46
  resStatus 97abb3ce97d2701aa229b493f0acf5c5
import  -/  Database.Memcache.Wire b9c0413f04d6ed449b906738485bee6f
  exports: c3c576dab15c3e91d5a4630c80e279e4
  recv 302e26b1b4927d798cf7479cc865b7b2
  send a9beebe72f375b15f7f3e22325124ac1
import  -/  network-2.6.2.1@netwo_A6pE0dLgMEk2GtUa1JtTJQ:Network.Socket 1c584aab086538b6f7ab7390a01794f4
b90589af8532425fc2203022602724aa
  type StatResults =
    [(Data.ByteString.Internal.ByteString,
      Data.ByteString.Internal.ByteString)]
89df1c8afb3b7596117041ae15ec0a57
  add ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Value
    -> Database.Memcache.Types.Flags
    -> Database.Memcache.Types.Expiration
    -> GHC.Types.IO (GHC.Base.Maybe Database.Memcache.Types.Version)
  {- Arity: 6,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Protocol.add1
                  `cast`
                (<Database.Memcache.Server.Server>_R
                 ->_R <Database.Memcache.Types.Key>_R
                 ->_R <Database.Memcache.Types.Value>_R
                 ->_R <Database.Memcache.Types.Flags>_R
                 ->_R <Database.Memcache.Types.Expiration>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0]
                               <GHC.Base.Maybe Database.Memcache.Types.Version>_R)) -}
892049e48037a1f5a595ce9d93805821
  add1 ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Value
    -> Database.Memcache.Types.Flags
    -> Database.Memcache.Types.Expiration
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Base.Maybe Database.Memcache.Types.Version #)
  {- Arity: 6,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U><L,U><L,U>,
     Unfolding: (\ c :: Database.Memcache.Server.Server
                   k :: Database.Memcache.Types.Key
                   v :: Database.Memcache.Types.Value
                   f :: Database.Memcache.Types.Flags
                   e :: Database.Memcache.Types.Expiration
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Database.Memcache.Server.sendRecv1
                        c
                        (Database.Memcache.Types.Req
                           (Database.Memcache.Types.ReqAdd
                              Database.Memcache.Types.Loud
                              k
                              v
                              (Database.Memcache.Types.SESet f e))
                           Database.Memcache.Types.emptyReq2
                           Database.Memcache.Types.emptyReq1)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case Database.Memcache.Types.$fEqIncorrectResponse_$c==
                        (Database.Memcache.Types.resOp ipv1)
                        Database.Memcache.Protocol.add4 of wild {
                   GHC.Types.False
                   -> case GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ ()
                             (Database.Memcache.Types.$fExceptionIncorrectResponse_$ctoException
                                (Database.Memcache.Types.IncorrectResponse
                                   (GHC.CString.unpackAppendCString#
                                      "Expected "#
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         Database.Memcache.Protocol.add3
                                         (GHC.CString.unpackAppendCString#
                                            " response! Got: "#
                                            (case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                                             Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                                               GHC.Show.shows18
                                               ds2
                                               (GHC.Types.[] @ GHC.Types.Char) }))))
                                   ipv1))
                             ipv
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                GHC.Base.Maybe Database.Memcache.Types.Version #)
                      of {}
                   GHC.Types.True
                   -> case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ (GHC.Base.Maybe Database.Memcache.Types.Version)
                             (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                (case wild2 of wild3 {
                                   Database.Memcache.Types.ErrKeyNotFound
                                   -> Database.Memcache.Errors.MemErrNoKey
                                   Database.Memcache.Types.ErrValueTooLarge
                                   -> Database.Memcache.Errors.MemErrValueTooLarge
                                   Database.Memcache.Types.ErrInvalidArgs
                                   -> Database.Memcache.Errors.MemErrInvalidArgs
                                   Database.Memcache.Types.ErrItemNotStored
                                   -> Database.Memcache.Errors.MemErrStoreFailed
                                   Database.Memcache.Types.ErrValueNonNumeric
                                   -> Database.Memcache.Errors.MemErrValueNonNumeric
                                   Database.Memcache.Types.ErrUnknownCommand
                                   -> Database.Memcache.Errors.MemErrUnknownCmd
                                   Database.Memcache.Types.ErrOutOfMemory
                                   -> Database.Memcache.Errors.MemErrOutOfMemory
                                   Database.Memcache.Types.SaslAuthFail
                                   -> Database.Memcache.Errors.MemErrAuthFail
                                   Database.Memcache.Types.SaslAuthContinue
                                   -> Database.Memcache.Protocol.add2 }))
                             ipv
                        Database.Memcache.Types.NoError
                        -> (# ipv, GHC.Base.Just @ Database.Memcache.Types.Version ds5 #)
                        Database.Memcache.Types.ErrKeyExists
                        -> (# ipv,
                              GHC.Base.Nothing @ Database.Memcache.Types.Version #) } } } }) -}
d56567cce044633de48c532d19019b65
  add2 :: Database.Memcache.Errors.MemcacheError
  {- Strictness: b -}
881dd450ced41bd06be545fd588d931e
  add3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ADD"#) -}
ed230255320d63a3f33d0d47505f1acf
  add4 :: Database.Memcache.Types.OpResponse
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Database.Memcache.Types.ResAdd
                   Database.Memcache.Types.Loud) -}
1e13f9408413d3175352cf055203fd4a
  append ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Value
    -> Database.Memcache.Types.Version
    -> GHC.Types.IO (GHC.Base.Maybe Database.Memcache.Types.Version)
  {- Arity: 5,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Protocol.append1
                  `cast`
                (<Database.Memcache.Server.Server>_R
                 ->_R <Database.Memcache.Types.Key>_R
                 ->_R <Database.Memcache.Types.Value>_R
                 ->_R <Database.Memcache.Types.Version>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0]
                               <GHC.Base.Maybe Database.Memcache.Types.Version>_R)) -}
3ef444cab8c3782a1d4485cd812e3bdb
  append1 ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Value
    -> Database.Memcache.Types.Version
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Base.Maybe Database.Memcache.Types.Version #)
  {- Arity: 5,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U(U)><L,U>,
     Unfolding: (\ c :: Database.Memcache.Server.Server
                   k :: Database.Memcache.Types.Key
                   v :: Database.Memcache.Types.Value
                   ver :: Database.Memcache.Types.Version
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Database.Memcache.Server.sendRecv1
                        c
                        (Database.Memcache.Types.Req
                           (Database.Memcache.Types.ReqAppend
                              Database.Memcache.Types.Loud
                              k
                              v)
                           Database.Memcache.Types.emptyReq2
                           ver)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case Database.Memcache.Types.$fEqIncorrectResponse_$c==
                        (Database.Memcache.Types.resOp ipv1)
                        Database.Memcache.Protocol.append3 of wild {
                   GHC.Types.False
                   -> case GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ ()
                             (Database.Memcache.Types.$fExceptionIncorrectResponse_$ctoException
                                (Database.Memcache.Types.IncorrectResponse
                                   (GHC.CString.unpackAppendCString#
                                      "Expected "#
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         Database.Memcache.Protocol.append2
                                         (GHC.CString.unpackAppendCString#
                                            " response! Got: "#
                                            (case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                                             Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                                               GHC.Show.shows18
                                               ds2
                                               (GHC.Types.[] @ GHC.Types.Char) }))))
                                   ipv1))
                             ipv
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                GHC.Base.Maybe Database.Memcache.Types.Version #)
                      of {}
                   GHC.Types.True
                   -> case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ (GHC.Base.Maybe Database.Memcache.Types.Version)
                             (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                (case wild2 of wild3 {
                                   Database.Memcache.Types.ErrKeyExists
                                   -> Database.Memcache.Errors.MemErrKeyExists
                                   Database.Memcache.Types.ErrValueTooLarge
                                   -> Database.Memcache.Errors.MemErrValueTooLarge
                                   Database.Memcache.Types.ErrInvalidArgs
                                   -> Database.Memcache.Errors.MemErrInvalidArgs
                                   Database.Memcache.Types.ErrItemNotStored
                                   -> Database.Memcache.Errors.MemErrStoreFailed
                                   Database.Memcache.Types.ErrValueNonNumeric
                                   -> Database.Memcache.Errors.MemErrValueNonNumeric
                                   Database.Memcache.Types.ErrUnknownCommand
                                   -> Database.Memcache.Errors.MemErrUnknownCmd
                                   Database.Memcache.Types.ErrOutOfMemory
                                   -> Database.Memcache.Errors.MemErrOutOfMemory
                                   Database.Memcache.Types.SaslAuthFail
                                   -> Database.Memcache.Errors.MemErrAuthFail
                                   Database.Memcache.Types.SaslAuthContinue
                                   -> Database.Memcache.Protocol.add2 }))
                             ipv
                        Database.Memcache.Types.NoError
                        -> (# ipv, GHC.Base.Just @ Database.Memcache.Types.Version ds5 #)
                        Database.Memcache.Types.ErrKeyNotFound
                        -> (# ipv,
                              GHC.Base.Nothing @ Database.Memcache.Types.Version #) } } } }) -}
fff7b8a28ba5ecd69bb7aeddf8f30707
  append2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "APPEND"#) -}
add087cd9c2f776fa874df6ab6c0a028
  append3 :: Database.Memcache.Types.OpResponse
  {- HasNoCafRefs, Strictness: m9,
     Unfolding: (Database.Memcache.Types.ResAppend
                   Database.Memcache.Types.Loud) -}
80d4c39c76afa58bb39ae68c90ef14fd
  decrement ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Initial
    -> Database.Memcache.Types.Delta
    -> Database.Memcache.Types.Expiration
    -> Database.Memcache.Types.Version
    -> GHC.Types.IO
         (GHC.Base.Maybe (GHC.Word.Word64, Database.Memcache.Types.Version))
  {- Arity: 7,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U><L,U><L,U(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Protocol.decrement1
                  `cast`
                (<Database.Memcache.Server.Server>_R
                 ->_R <Database.Memcache.Types.Key>_R
                 ->_R <Database.Memcache.Types.Initial>_R
                 ->_R <Database.Memcache.Types.Delta>_R
                 ->_R <Database.Memcache.Types.Expiration>_R
                 ->_R <Database.Memcache.Types.Version>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0]
                               <GHC.Base.Maybe
                                  (GHC.Word.Word64, Database.Memcache.Types.Version)>_R)) -}
486cb35151326c4e782e15459d7f73c9
  decrement1 ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Initial
    -> Database.Memcache.Types.Delta
    -> Database.Memcache.Types.Expiration
    -> Database.Memcache.Types.Version
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Base.Maybe
            (GHC.Word.Word64, Database.Memcache.Types.Version) #)
  {- Arity: 7,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U><L,U><L,U(U)><L,U>,
     Unfolding: (\ c :: Database.Memcache.Server.Server
                   k :: Database.Memcache.Types.Key
                   i :: Database.Memcache.Types.Initial
                   d :: Database.Memcache.Types.Delta
                   e :: Database.Memcache.Types.Expiration
                   ver :: Database.Memcache.Types.Version
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Database.Memcache.Server.sendRecv1
                        c
                        (Database.Memcache.Types.Req
                           (Database.Memcache.Types.ReqDecrement
                              Database.Memcache.Types.Loud
                              k
                              (Database.Memcache.Types.SEIncr i d e))
                           Database.Memcache.Types.emptyReq2
                           ver)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                 let {
                   $wa :: GHC.Prim.State# GHC.Prim.RealWorld
                          -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word64 #)
                     {- Arity: 1, Strictness: <B,U>b, Inline: [0] -}
                   = \ w :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                     GHC.Prim.raiseIO#
                       @ GHC.Exception.SomeException
                       @ GHC.Word.Word64
                       (Database.Memcache.Types.$fExceptionIncorrectResponse_$ctoException
                          (Database.Memcache.Types.IncorrectResponse
                             (GHC.CString.unpackAppendCString#
                                "Expected "#
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   Database.Memcache.Protocol.decrement2
                                   (GHC.CString.unpackAppendCString#
                                      " response! Got: "#
                                      (Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                                         GHC.Show.shows18
                                         ds2
                                         (GHC.Types.[] @ GHC.Types.Char)))))
                             wild))
                       w
                 } in
                 case ds2 of wild1 {
                   DEFAULT
                   -> case $wa ipv
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                GHC.Base.Maybe
                                  (GHC.Word.Word64, Database.Memcache.Types.Version) #)
                      of {}
                   Database.Memcache.Types.ResDecrement ds n
                   -> case ds of wild2 {
                        Database.Memcache.Types.Loud
                        -> case ds3 of wild3 {
                             DEFAULT
                             -> GHC.Prim.raiseIO#
                                  @ GHC.Exception.SomeException
                                  @ (GHC.Base.Maybe
                                       (GHC.Word.Word64, Database.Memcache.Types.Version))
                                  (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                     (case wild3 of wild4 {
                                        Database.Memcache.Types.ErrValueTooLarge
                                        -> Database.Memcache.Errors.MemErrValueTooLarge
                                        Database.Memcache.Types.ErrInvalidArgs
                                        -> Database.Memcache.Errors.MemErrInvalidArgs
                                        Database.Memcache.Types.ErrItemNotStored
                                        -> Database.Memcache.Errors.MemErrStoreFailed
                                        Database.Memcache.Types.ErrValueNonNumeric
                                        -> Database.Memcache.Errors.MemErrValueNonNumeric
                                        Database.Memcache.Types.ErrUnknownCommand
                                        -> Database.Memcache.Errors.MemErrUnknownCmd
                                        Database.Memcache.Types.ErrOutOfMemory
                                        -> Database.Memcache.Errors.MemErrOutOfMemory
                                        Database.Memcache.Types.SaslAuthFail
                                        -> Database.Memcache.Errors.MemErrAuthFail
                                        Database.Memcache.Types.SaslAuthContinue
                                        -> Database.Memcache.Protocol.add2 }))
                                  ipv
                             Database.Memcache.Types.NoError
                             -> (# ipv,
                                   GHC.Base.Just
                                     @ (GHC.Word.Word64, Database.Memcache.Types.Version)
                                     (n, ds5) #)
                             Database.Memcache.Types.ErrKeyNotFound
                             -> (# ipv,
                                   GHC.Base.Nothing
                                     @ (GHC.Word.Word64, Database.Memcache.Types.Version) #)
                             Database.Memcache.Types.ErrKeyExists
                             -> (# ipv,
                                   GHC.Base.Nothing
                                     @ (GHC.Word.Word64, Database.Memcache.Types.Version) #) }
                        Database.Memcache.Types.Quiet
                        -> case $wa ipv
                           ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                     GHC.Base.Maybe
                                       (GHC.Word.Word64, Database.Memcache.Types.Version) #)
                           of {} } } } }) -}
76fc275a91267935bea5d3b7c775cd42
  decrement2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DECREMENT"#) -}
e071edc9d783ab9b43bcf42adb955bf3
  delete ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Version
    -> GHC.Types.IO GHC.Types.Bool
  {- Arity: 4,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Protocol.delete1
                  `cast`
                (<Database.Memcache.Server.Server>_R
                 ->_R <Database.Memcache.Types.Key>_R
                 ->_R <Database.Memcache.Types.Version>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <GHC.Types.Bool>_R)) -}
38d4eb6ffe8762df5d23c1ce3feddf17
  delete1 ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Version
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Bool #)
  {- Arity: 4,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U(U)><L,U>,
     Unfolding: (\ c :: Database.Memcache.Server.Server
                   k :: Database.Memcache.Types.Key
                   ver :: Database.Memcache.Types.Version
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Database.Memcache.Server.sendRecv1
                        c
                        (Database.Memcache.Types.Req
                           (Database.Memcache.Types.ReqDelete Database.Memcache.Types.Loud k)
                           Database.Memcache.Types.emptyReq2
                           ver)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case Database.Memcache.Types.$fEqIncorrectResponse_$c==
                        (Database.Memcache.Types.resOp ipv1)
                        Database.Memcache.Protocol.delete3 of wild {
                   GHC.Types.False
                   -> case GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ ()
                             (Database.Memcache.Types.$fExceptionIncorrectResponse_$ctoException
                                (Database.Memcache.Types.IncorrectResponse
                                   (GHC.CString.unpackAppendCString#
                                      "Expected "#
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         Database.Memcache.Protocol.delete2
                                         (GHC.CString.unpackAppendCString#
                                            " response! Got: "#
                                            (case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                                             Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                                               GHC.Show.shows18
                                               ds2
                                               (GHC.Types.[] @ GHC.Types.Char) }))))
                                   ipv1))
                             ipv
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Bool #)
                      of {}
                   GHC.Types.True
                   -> case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ GHC.Types.Bool
                             (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                (case wild2 of wild3 {
                                   Database.Memcache.Types.ErrValueTooLarge
                                   -> Database.Memcache.Errors.MemErrValueTooLarge
                                   Database.Memcache.Types.ErrInvalidArgs
                                   -> Database.Memcache.Errors.MemErrInvalidArgs
                                   Database.Memcache.Types.ErrItemNotStored
                                   -> Database.Memcache.Errors.MemErrStoreFailed
                                   Database.Memcache.Types.ErrValueNonNumeric
                                   -> Database.Memcache.Errors.MemErrValueNonNumeric
                                   Database.Memcache.Types.ErrUnknownCommand
                                   -> Database.Memcache.Errors.MemErrUnknownCmd
                                   Database.Memcache.Types.ErrOutOfMemory
                                   -> Database.Memcache.Errors.MemErrOutOfMemory
                                   Database.Memcache.Types.SaslAuthFail
                                   -> Database.Memcache.Errors.MemErrAuthFail
                                   Database.Memcache.Types.SaslAuthContinue
                                   -> Database.Memcache.Protocol.add2 }))
                             ipv
                        Database.Memcache.Types.NoError -> (# ipv, GHC.Types.True #)
                        Database.Memcache.Types.ErrKeyNotFound
                        -> (# ipv, GHC.Types.False #)
                        Database.Memcache.Types.ErrKeyExists
                        -> (# ipv, GHC.Types.False #) } } } }) -}
7e4d3b9c23e25e6c6668a7fa0ba3dd02
  delete2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DELETE"#) -}
dc148528e3a0c1164ba397ae8018fe01
  delete3 :: Database.Memcache.Types.OpResponse
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (Database.Memcache.Types.ResDelete
                   Database.Memcache.Types.Loud) -}
6de9ec37ad2902425eda18decc9cb6fa
  flush ::
    Database.Memcache.Server.Server
    -> GHC.Base.Maybe Database.Memcache.Types.Expiration
    -> GHC.Types.IO ()
  {- Arity: 3,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Protocol.flush1
                  `cast`
                (<Database.Memcache.Server.Server>_R
                 ->_R <GHC.Base.Maybe Database.Memcache.Types.Expiration>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
52222a12f42dcb8fe42e9edb1d0b632b
  flush1 ::
    Database.Memcache.Server.Server
    -> GHC.Base.Maybe Database.Memcache.Types.Expiration
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,1*U><L,U>,
     Unfolding: (\ c :: Database.Memcache.Server.Server
                   e :: GHC.Base.Maybe Database.Memcache.Types.Expiration
                   s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Database.Memcache.Server.sendRecv1
                        c
                        (Database.Memcache.Types.Req
                           (Database.Memcache.Types.ReqFlush
                              Database.Memcache.Types.Loud
                              (case e of wild {
                                 GHC.Base.Nothing
                                 -> GHC.Base.Nothing @ Database.Memcache.Types.SETouch
                                 GHC.Base.Just a1
                                 -> GHC.Base.Just
                                      @ Database.Memcache.Types.SETouch
                                      (Database.Memcache.Types.SETouch a1) }))
                           Database.Memcache.Types.emptyReq2
                           Database.Memcache.Types.emptyReq1)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case Database.Memcache.Types.$fEqIncorrectResponse_$c==
                        (Database.Memcache.Types.resOp ipv1)
                        Database.Memcache.Protocol.flush3 of wild {
                   GHC.Types.False
                   -> GHC.Prim.raiseIO#
                        @ GHC.Exception.SomeException
                        @ ()
                        (Database.Memcache.Types.$fExceptionIncorrectResponse_$ctoException
                           (Database.Memcache.Types.IncorrectResponse
                              (GHC.CString.unpackAppendCString#
                                 "Expected "#
                                 (GHC.Base.++
                                    @ GHC.Types.Char
                                    Database.Memcache.Protocol.flush2
                                    (GHC.CString.unpackAppendCString#
                                       " response! Got: "#
                                       (case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                                        Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                                          GHC.Show.shows18
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char) }))))
                              ipv1))
                        ipv
                   GHC.Types.True
                   -> case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ ()
                             (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                (case wild2 of wild3 {
                                   Database.Memcache.Types.ErrKeyNotFound
                                   -> Database.Memcache.Errors.MemErrNoKey
                                   Database.Memcache.Types.ErrKeyExists
                                   -> Database.Memcache.Errors.MemErrKeyExists
                                   Database.Memcache.Types.ErrValueTooLarge
                                   -> Database.Memcache.Errors.MemErrValueTooLarge
                                   Database.Memcache.Types.ErrInvalidArgs
                                   -> Database.Memcache.Errors.MemErrInvalidArgs
                                   Database.Memcache.Types.ErrItemNotStored
                                   -> Database.Memcache.Errors.MemErrStoreFailed
                                   Database.Memcache.Types.ErrValueNonNumeric
                                   -> Database.Memcache.Errors.MemErrValueNonNumeric
                                   Database.Memcache.Types.ErrUnknownCommand
                                   -> Database.Memcache.Errors.MemErrUnknownCmd
                                   Database.Memcache.Types.ErrOutOfMemory
                                   -> Database.Memcache.Errors.MemErrOutOfMemory
                                   Database.Memcache.Types.SaslAuthFail
                                   -> Database.Memcache.Errors.MemErrAuthFail
                                   Database.Memcache.Types.SaslAuthContinue
                                   -> Database.Memcache.Protocol.add2 }))
                             ipv
                        Database.Memcache.Types.NoError
                        -> (# ipv, GHC.Tuple.() #) } } } }) -}
2dc9f6d3f6d8226e60c6e19373356c9e
  flush2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FLUSH"#) -}
f4a90170efeb4fee3a3a6fe4c6f7b431
  flush3 :: Database.Memcache.Types.OpResponse
  {- HasNoCafRefs, Strictness: m14,
     Unfolding: (Database.Memcache.Types.ResFlush
                   Database.Memcache.Types.Loud) -}
7611444457dd365c429dafa04c94ca7d
  gat ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Expiration
    -> GHC.Types.IO
         (GHC.Base.Maybe
            (Database.Memcache.Types.Value,
             Database.Memcache.Types.Flags,
             Database.Memcache.Types.Version))
  {- Arity: 4,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Protocol.gat1
                  `cast`
                (<Database.Memcache.Server.Server>_R
                 ->_R <Database.Memcache.Types.Key>_R
                 ->_R <Database.Memcache.Types.Expiration>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0]
                               <GHC.Base.Maybe
                                  (Database.Memcache.Types.Value,
                                   Database.Memcache.Types.Flags,
                                   Database.Memcache.Types.Version)>_R)) -}
9f2d1b386eb849039023e05c01deff75
  gat1 ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Expiration
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Base.Maybe
            (Database.Memcache.Types.Value,
             Database.Memcache.Types.Flags,
             Database.Memcache.Types.Version) #)
  {- Arity: 4,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U>,
     Unfolding: (\ c :: Database.Memcache.Server.Server
                   k :: Database.Memcache.Types.Key
                   e :: Database.Memcache.Types.Expiration
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Database.Memcache.Server.sendRecv1
                        c
                        (Database.Memcache.Types.Req
                           (Database.Memcache.Types.ReqGAT
                              Database.Memcache.Types.Loud
                              Database.Memcache.Types.NoKey
                              k
                              (Database.Memcache.Types.SETouch e))
                           Database.Memcache.Types.emptyReq2
                           Database.Memcache.Types.emptyReq1)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                 let {
                   $wa :: GHC.Prim.State# GHC.Prim.RealWorld
                          -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                (Database.Memcache.Types.Value, Database.Memcache.Types.Flags) #)
                     {- Arity: 1, Strictness: <B,U>b, Inline: [0] -}
                   = \ w :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                     GHC.Prim.raiseIO#
                       @ GHC.Exception.SomeException
                       @ (Database.Memcache.Types.Value, Database.Memcache.Types.Flags)
                       (Database.Memcache.Types.$fExceptionIncorrectResponse_$ctoException
                          (Database.Memcache.Types.IncorrectResponse
                             (GHC.CString.unpackAppendCString#
                                "Expected "#
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   Database.Memcache.Protocol.gat2
                                   (GHC.CString.unpackAppendCString#
                                      " response! Got: "#
                                      (Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                                         GHC.Show.shows18
                                         ds2
                                         (GHC.Types.[] @ GHC.Types.Char)))))
                             wild))
                       w
                 } in
                 case ds2 of wild1 {
                   DEFAULT
                   -> case $wa ipv
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                GHC.Base.Maybe
                                  (Database.Memcache.Types.Value,
                                   Database.Memcache.Types.Flags,
                                   Database.Memcache.Types.Version) #)
                      of {}
                   Database.Memcache.Types.ResGAT ds v f
                   -> case ds of wild2 {
                        Database.Memcache.Types.Loud
                        -> case ds3 of wild3 {
                             DEFAULT
                             -> GHC.Prim.raiseIO#
                                  @ GHC.Exception.SomeException
                                  @ (GHC.Base.Maybe
                                       (Database.Memcache.Types.Value,
                                        Database.Memcache.Types.Flags,
                                        Database.Memcache.Types.Version))
                                  (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                     (case wild3 of wild4 {
                                        Database.Memcache.Types.ErrKeyExists
                                        -> Database.Memcache.Errors.MemErrKeyExists
                                        Database.Memcache.Types.ErrValueTooLarge
                                        -> Database.Memcache.Errors.MemErrValueTooLarge
                                        Database.Memcache.Types.ErrInvalidArgs
                                        -> Database.Memcache.Errors.MemErrInvalidArgs
                                        Database.Memcache.Types.ErrItemNotStored
                                        -> Database.Memcache.Errors.MemErrStoreFailed
                                        Database.Memcache.Types.ErrValueNonNumeric
                                        -> Database.Memcache.Errors.MemErrValueNonNumeric
                                        Database.Memcache.Types.ErrUnknownCommand
                                        -> Database.Memcache.Errors.MemErrUnknownCmd
                                        Database.Memcache.Types.ErrOutOfMemory
                                        -> Database.Memcache.Errors.MemErrOutOfMemory
                                        Database.Memcache.Types.SaslAuthFail
                                        -> Database.Memcache.Errors.MemErrAuthFail
                                        Database.Memcache.Types.SaslAuthContinue
                                        -> Database.Memcache.Protocol.add2 }))
                                  ipv
                             Database.Memcache.Types.NoError
                             -> (# ipv,
                                   GHC.Base.Just
                                     @ (Database.Memcache.Types.Value,
                                        Database.Memcache.Types.Flags,
                                        Database.Memcache.Types.Version)
                                     (v, f, ds5) #)
                             Database.Memcache.Types.ErrKeyNotFound
                             -> (# ipv,
                                   GHC.Base.Nothing
                                     @ (Database.Memcache.Types.Value,
                                        Database.Memcache.Types.Flags,
                                        Database.Memcache.Types.Version) #) }
                        Database.Memcache.Types.Quiet
                        -> case $wa ipv
                           ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                     GHC.Base.Maybe
                                       (Database.Memcache.Types.Value,
                                        Database.Memcache.Types.Flags,
                                        Database.Memcache.Types.Version) #)
                           of {} } } } }) -}
be70afc44ae93f86e1e668198997e550
  gat2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GAT"#) -}
8a1d91a99dd7912ec06dae256a5e7ca5
  get ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> GHC.Types.IO
         (GHC.Base.Maybe
            (Database.Memcache.Types.Value,
             Database.Memcache.Types.Flags,
             Database.Memcache.Types.Version))
  {- Arity: 3,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Protocol.get1
                  `cast`
                (<Database.Memcache.Server.Server>_R
                 ->_R <Database.Memcache.Types.Key>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0]
                               <GHC.Base.Maybe
                                  (Database.Memcache.Types.Value,
                                   Database.Memcache.Types.Flags,
                                   Database.Memcache.Types.Version)>_R)) -}
2bfe057e92725115a37423aa3ba0f341
  get1 ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Base.Maybe
            (Database.Memcache.Types.Value,
             Database.Memcache.Types.Flags,
             Database.Memcache.Types.Version) #)
  {- Arity: 3,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U>,
     Unfolding: (\ c :: Database.Memcache.Server.Server
                   k :: Database.Memcache.Types.Key
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Database.Memcache.Server.sendRecv1
                        c
                        (Database.Memcache.Types.Req
                           (Database.Memcache.Types.ReqGet
                              Database.Memcache.Types.Loud
                              Database.Memcache.Types.NoKey
                              k)
                           Database.Memcache.Types.emptyReq2
                           Database.Memcache.Types.emptyReq1)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                 let {
                   $wa :: GHC.Prim.State# GHC.Prim.RealWorld
                          -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                (Database.Memcache.Types.Value, Database.Memcache.Types.Flags) #)
                     {- Arity: 1, Strictness: <B,U>b, Inline: [0] -}
                   = \ w :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                     GHC.Prim.raiseIO#
                       @ GHC.Exception.SomeException
                       @ (Database.Memcache.Types.Value, Database.Memcache.Types.Flags)
                       (Database.Memcache.Types.$fExceptionIncorrectResponse_$ctoException
                          (Database.Memcache.Types.IncorrectResponse
                             (GHC.CString.unpackAppendCString#
                                "Expected "#
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   Database.Memcache.Protocol.get2
                                   (GHC.CString.unpackAppendCString#
                                      " response! Got: "#
                                      (Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                                         GHC.Show.shows18
                                         ds2
                                         (GHC.Types.[] @ GHC.Types.Char)))))
                             wild))
                       w
                 } in
                 case ds2 of wild1 {
                   DEFAULT
                   -> case $wa ipv
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                GHC.Base.Maybe
                                  (Database.Memcache.Types.Value,
                                   Database.Memcache.Types.Flags,
                                   Database.Memcache.Types.Version) #)
                      of {}
                   Database.Memcache.Types.ResGet ds v f
                   -> case ds of wild2 {
                        Database.Memcache.Types.Loud
                        -> case ds3 of wild3 {
                             DEFAULT
                             -> GHC.Prim.raiseIO#
                                  @ GHC.Exception.SomeException
                                  @ (GHC.Base.Maybe
                                       (Database.Memcache.Types.Value,
                                        Database.Memcache.Types.Flags,
                                        Database.Memcache.Types.Version))
                                  (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                     (case wild3 of wild4 {
                                        Database.Memcache.Types.ErrKeyExists
                                        -> Database.Memcache.Errors.MemErrKeyExists
                                        Database.Memcache.Types.ErrValueTooLarge
                                        -> Database.Memcache.Errors.MemErrValueTooLarge
                                        Database.Memcache.Types.ErrInvalidArgs
                                        -> Database.Memcache.Errors.MemErrInvalidArgs
                                        Database.Memcache.Types.ErrItemNotStored
                                        -> Database.Memcache.Errors.MemErrStoreFailed
                                        Database.Memcache.Types.ErrValueNonNumeric
                                        -> Database.Memcache.Errors.MemErrValueNonNumeric
                                        Database.Memcache.Types.ErrUnknownCommand
                                        -> Database.Memcache.Errors.MemErrUnknownCmd
                                        Database.Memcache.Types.ErrOutOfMemory
                                        -> Database.Memcache.Errors.MemErrOutOfMemory
                                        Database.Memcache.Types.SaslAuthFail
                                        -> Database.Memcache.Errors.MemErrAuthFail
                                        Database.Memcache.Types.SaslAuthContinue
                                        -> Database.Memcache.Protocol.add2 }))
                                  ipv
                             Database.Memcache.Types.NoError
                             -> (# ipv,
                                   GHC.Base.Just
                                     @ (Database.Memcache.Types.Value,
                                        Database.Memcache.Types.Flags,
                                        Database.Memcache.Types.Version)
                                     (v, f, ds5) #)
                             Database.Memcache.Types.ErrKeyNotFound
                             -> (# ipv,
                                   GHC.Base.Nothing
                                     @ (Database.Memcache.Types.Value,
                                        Database.Memcache.Types.Flags,
                                        Database.Memcache.Types.Version) #) }
                        Database.Memcache.Types.Quiet
                        -> case $wa ipv
                           ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                     GHC.Base.Maybe
                                       (Database.Memcache.Types.Value,
                                        Database.Memcache.Types.Flags,
                                        Database.Memcache.Types.Version) #)
                           of {} } } } }) -}
d4d11aacf46455d5c3b132e242351ffe
  get2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GET"#) -}
cde3f153242ae4e96fdf826019493d93
  increment ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Initial
    -> Database.Memcache.Types.Delta
    -> Database.Memcache.Types.Expiration
    -> Database.Memcache.Types.Version
    -> GHC.Types.IO
         (GHC.Base.Maybe (GHC.Word.Word64, Database.Memcache.Types.Version))
  {- Arity: 7,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U><L,U><L,U(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Protocol.increment1
                  `cast`
                (<Database.Memcache.Server.Server>_R
                 ->_R <Database.Memcache.Types.Key>_R
                 ->_R <Database.Memcache.Types.Initial>_R
                 ->_R <Database.Memcache.Types.Delta>_R
                 ->_R <Database.Memcache.Types.Expiration>_R
                 ->_R <Database.Memcache.Types.Version>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0]
                               <GHC.Base.Maybe
                                  (GHC.Word.Word64, Database.Memcache.Types.Version)>_R)) -}
38385f358c4d11226a640c7bcfcbc382
  increment1 ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Initial
    -> Database.Memcache.Types.Delta
    -> Database.Memcache.Types.Expiration
    -> Database.Memcache.Types.Version
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Base.Maybe
            (GHC.Word.Word64, Database.Memcache.Types.Version) #)
  {- Arity: 7,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U><L,U><L,U(U)><L,U>,
     Unfolding: (\ c :: Database.Memcache.Server.Server
                   k :: Database.Memcache.Types.Key
                   i :: Database.Memcache.Types.Initial
                   d :: Database.Memcache.Types.Delta
                   e :: Database.Memcache.Types.Expiration
                   ver :: Database.Memcache.Types.Version
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Database.Memcache.Server.sendRecv1
                        c
                        (Database.Memcache.Types.Req
                           (Database.Memcache.Types.ReqIncrement
                              Database.Memcache.Types.Loud
                              k
                              (Database.Memcache.Types.SEIncr i d e))
                           Database.Memcache.Types.emptyReq2
                           ver)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                 let {
                   $wa :: GHC.Prim.State# GHC.Prim.RealWorld
                          -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word64 #)
                     {- Arity: 1, Strictness: <B,U>b, Inline: [0] -}
                   = \ w :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                     GHC.Prim.raiseIO#
                       @ GHC.Exception.SomeException
                       @ GHC.Word.Word64
                       (Database.Memcache.Types.$fExceptionIncorrectResponse_$ctoException
                          (Database.Memcache.Types.IncorrectResponse
                             (GHC.CString.unpackAppendCString#
                                "Expected "#
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   Database.Memcache.Protocol.increment2
                                   (GHC.CString.unpackAppendCString#
                                      " response! Got: "#
                                      (Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                                         GHC.Show.shows18
                                         ds2
                                         (GHC.Types.[] @ GHC.Types.Char)))))
                             wild))
                       w
                 } in
                 case ds2 of wild1 {
                   DEFAULT
                   -> case $wa ipv
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                GHC.Base.Maybe
                                  (GHC.Word.Word64, Database.Memcache.Types.Version) #)
                      of {}
                   Database.Memcache.Types.ResIncrement ds n
                   -> case ds of wild2 {
                        Database.Memcache.Types.Loud
                        -> case ds3 of wild3 {
                             DEFAULT
                             -> GHC.Prim.raiseIO#
                                  @ GHC.Exception.SomeException
                                  @ (GHC.Base.Maybe
                                       (GHC.Word.Word64, Database.Memcache.Types.Version))
                                  (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                     (case wild3 of wild4 {
                                        Database.Memcache.Types.ErrValueTooLarge
                                        -> Database.Memcache.Errors.MemErrValueTooLarge
                                        Database.Memcache.Types.ErrInvalidArgs
                                        -> Database.Memcache.Errors.MemErrInvalidArgs
                                        Database.Memcache.Types.ErrItemNotStored
                                        -> Database.Memcache.Errors.MemErrStoreFailed
                                        Database.Memcache.Types.ErrValueNonNumeric
                                        -> Database.Memcache.Errors.MemErrValueNonNumeric
                                        Database.Memcache.Types.ErrUnknownCommand
                                        -> Database.Memcache.Errors.MemErrUnknownCmd
                                        Database.Memcache.Types.ErrOutOfMemory
                                        -> Database.Memcache.Errors.MemErrOutOfMemory
                                        Database.Memcache.Types.SaslAuthFail
                                        -> Database.Memcache.Errors.MemErrAuthFail
                                        Database.Memcache.Types.SaslAuthContinue
                                        -> Database.Memcache.Protocol.add2 }))
                                  ipv
                             Database.Memcache.Types.NoError
                             -> (# ipv,
                                   GHC.Base.Just
                                     @ (GHC.Word.Word64, Database.Memcache.Types.Version)
                                     (n, ds5) #)
                             Database.Memcache.Types.ErrKeyNotFound
                             -> (# ipv,
                                   GHC.Base.Nothing
                                     @ (GHC.Word.Word64, Database.Memcache.Types.Version) #)
                             Database.Memcache.Types.ErrKeyExists
                             -> (# ipv,
                                   GHC.Base.Nothing
                                     @ (GHC.Word.Word64, Database.Memcache.Types.Version) #) }
                        Database.Memcache.Types.Quiet
                        -> case $wa ipv
                           ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                     GHC.Base.Maybe
                                       (GHC.Word.Word64, Database.Memcache.Types.Version) #)
                           of {} } } } }) -}
16165aec4c65617900da22263aa16b8b
  increment2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "INCREMENT"#) -}
df134653520e829cb8a6400c11836694
  noop :: Database.Memcache.Server.Server -> GHC.Types.IO ()
  {- Arity: 2,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Protocol.noop1
                  `cast`
                (<Database.Memcache.Server.Server>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
e2419937917a6a98d2bdc1422dff5a98
  noop1 ::
    Database.Memcache.Server.Server
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U>,
     Unfolding: (\ c :: Database.Memcache.Server.Server
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Database.Memcache.Server.sendRecv1
                        c
                        Database.Memcache.Protocol.noop3
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case Database.Memcache.Types.$fEqIncorrectResponse_$c==
                        (Database.Memcache.Types.resOp ipv1)
                        Database.Memcache.Types.ResNoop of wild {
                   GHC.Types.False
                   -> GHC.Prim.raiseIO#
                        @ GHC.Exception.SomeException
                        @ ()
                        (Database.Memcache.Types.$fExceptionIncorrectResponse_$ctoException
                           (Database.Memcache.Types.IncorrectResponse
                              (GHC.CString.unpackAppendCString#
                                 "Expected "#
                                 (GHC.Base.++
                                    @ GHC.Types.Char
                                    Database.Memcache.Protocol.noop2
                                    (GHC.CString.unpackAppendCString#
                                       " response! Got: "#
                                       (case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                                        Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                                          GHC.Show.shows18
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char) }))))
                              ipv1))
                        ipv
                   GHC.Types.True
                   -> case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ ()
                             (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                (case wild2 of wild3 {
                                   Database.Memcache.Types.ErrKeyNotFound
                                   -> Database.Memcache.Errors.MemErrNoKey
                                   Database.Memcache.Types.ErrKeyExists
                                   -> Database.Memcache.Errors.MemErrKeyExists
                                   Database.Memcache.Types.ErrValueTooLarge
                                   -> Database.Memcache.Errors.MemErrValueTooLarge
                                   Database.Memcache.Types.ErrInvalidArgs
                                   -> Database.Memcache.Errors.MemErrInvalidArgs
                                   Database.Memcache.Types.ErrItemNotStored
                                   -> Database.Memcache.Errors.MemErrStoreFailed
                                   Database.Memcache.Types.ErrValueNonNumeric
                                   -> Database.Memcache.Errors.MemErrValueNonNumeric
                                   Database.Memcache.Types.ErrUnknownCommand
                                   -> Database.Memcache.Errors.MemErrUnknownCmd
                                   Database.Memcache.Types.ErrOutOfMemory
                                   -> Database.Memcache.Errors.MemErrOutOfMemory
                                   Database.Memcache.Types.SaslAuthFail
                                   -> Database.Memcache.Errors.MemErrAuthFail
                                   Database.Memcache.Types.SaslAuthContinue
                                   -> Database.Memcache.Protocol.add2 }))
                             ipv
                        Database.Memcache.Types.NoError
                        -> (# ipv, GHC.Tuple.() #) } } } }) -}
7dbbb34783e486df27bb2510c37e349d
  noop2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NOOP"#) -}
faf2438eba48e7d76a712cbf94843396
  noop3 :: Database.Memcache.Types.Request
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Database.Memcache.Types.Req
                   Database.Memcache.Types.ReqNoop
                   Database.Memcache.Types.emptyReq2
                   Database.Memcache.Types.emptyReq1) -}
4b00cd9780bfe6531ecdd1200d8f6f7c
  prepend ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Value
    -> Database.Memcache.Types.Version
    -> GHC.Types.IO (GHC.Base.Maybe Database.Memcache.Types.Version)
  {- Arity: 5,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Protocol.prepend1
                  `cast`
                (<Database.Memcache.Server.Server>_R
                 ->_R <Database.Memcache.Types.Key>_R
                 ->_R <Database.Memcache.Types.Value>_R
                 ->_R <Database.Memcache.Types.Version>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0]
                               <GHC.Base.Maybe Database.Memcache.Types.Version>_R)) -}
4a6aed86a8d2ede9c340acdecc176484
  prepend1 ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Value
    -> Database.Memcache.Types.Version
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Base.Maybe Database.Memcache.Types.Version #)
  {- Arity: 5,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U(U)><L,U>,
     Unfolding: (\ c :: Database.Memcache.Server.Server
                   k :: Database.Memcache.Types.Key
                   v :: Database.Memcache.Types.Value
                   ver :: Database.Memcache.Types.Version
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Database.Memcache.Server.sendRecv1
                        c
                        (Database.Memcache.Types.Req
                           (Database.Memcache.Types.ReqPrepend
                              Database.Memcache.Types.Loud
                              k
                              v)
                           Database.Memcache.Types.emptyReq2
                           ver)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case Database.Memcache.Types.$fEqIncorrectResponse_$c==
                        (Database.Memcache.Types.resOp ipv1)
                        Database.Memcache.Protocol.prepend3 of wild {
                   GHC.Types.False
                   -> case GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ ()
                             (Database.Memcache.Types.$fExceptionIncorrectResponse_$ctoException
                                (Database.Memcache.Types.IncorrectResponse
                                   (GHC.CString.unpackAppendCString#
                                      "Expected "#
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         Database.Memcache.Protocol.prepend2
                                         (GHC.CString.unpackAppendCString#
                                            " response! Got: "#
                                            (case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                                             Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                                               GHC.Show.shows18
                                               ds2
                                               (GHC.Types.[] @ GHC.Types.Char) }))))
                                   ipv1))
                             ipv
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                GHC.Base.Maybe Database.Memcache.Types.Version #)
                      of {}
                   GHC.Types.True
                   -> case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ (GHC.Base.Maybe Database.Memcache.Types.Version)
                             (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                (case wild2 of wild3 {
                                   Database.Memcache.Types.ErrKeyExists
                                   -> Database.Memcache.Errors.MemErrKeyExists
                                   Database.Memcache.Types.ErrValueTooLarge
                                   -> Database.Memcache.Errors.MemErrValueTooLarge
                                   Database.Memcache.Types.ErrInvalidArgs
                                   -> Database.Memcache.Errors.MemErrInvalidArgs
                                   Database.Memcache.Types.ErrItemNotStored
                                   -> Database.Memcache.Errors.MemErrStoreFailed
                                   Database.Memcache.Types.ErrValueNonNumeric
                                   -> Database.Memcache.Errors.MemErrValueNonNumeric
                                   Database.Memcache.Types.ErrUnknownCommand
                                   -> Database.Memcache.Errors.MemErrUnknownCmd
                                   Database.Memcache.Types.ErrOutOfMemory
                                   -> Database.Memcache.Errors.MemErrOutOfMemory
                                   Database.Memcache.Types.SaslAuthFail
                                   -> Database.Memcache.Errors.MemErrAuthFail
                                   Database.Memcache.Types.SaslAuthContinue
                                   -> Database.Memcache.Protocol.add2 }))
                             ipv
                        Database.Memcache.Types.NoError
                        -> (# ipv, GHC.Base.Just @ Database.Memcache.Types.Version ds5 #)
                        Database.Memcache.Types.ErrKeyNotFound
                        -> (# ipv,
                              GHC.Base.Nothing @ Database.Memcache.Types.Version #) } } } }) -}
f425365a955d16760f157d798d049081
  prepend2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PREPEND"#) -}
134abdb938110444ffd54a122864f247
  prepend3 :: Database.Memcache.Types.OpResponse
  {- HasNoCafRefs, Strictness: m10,
     Unfolding: (Database.Memcache.Types.ResPrepend
                   Database.Memcache.Types.Loud) -}
911655f3d782c38f14a90d03b15517fc
  quit :: Database.Memcache.Server.Server -> GHC.Types.IO ()
  {- Arity: 2,
     Strictness: <L,U(A,U(C(U),C(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),H,A,H,H)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Protocol.quit1
                  `cast`
                (<Database.Memcache.Server.Server>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
717dcea3cc2dd0aa5b0e165404fc071a
  quit1 ::
    Database.Memcache.Server.Server
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2,
     Strictness: <L,U(A,U(C(U),C(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),H,A,H,H)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ c :: Database.Memcache.Server.Server
                   s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Data.Pool.withResource1
                        @ Network.Socket.Types.Socket
                        @ ()
                        (case c of wild { Database.Memcache.Server.Server dt ds ds1 dt1 ds2 ds3 ->
                         ds })
                        Database.Memcache.Protocol.quit2
                          `cast`
                        (<Network.Socket.Types.Socket>_R
                         ->_R Sym (GHC.Types.NTCo:IO[0] <()>_R))
                        s of ds1 { (#,#) ipv ipv1 ->
                 Database.Memcache.Server.close1 c ipv }) -}
669133f302b261fc964458ca6c341911
  quit2 ::
    Network.Socket.Types.Socket
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,1*U(U(U),A,A,A,A)><L,U>,
     Unfolding: (\ s :: Network.Socket.Types.Socket
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 GHC.Prim.catch#
                   @ ()
                   @ GHC.Exception.SomeException
                   (\ s1 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                    case s of ww { Network.Socket.Types.MkSocket ww1 ww2 ww3 ww4 ww5 ->
                    case Database.Memcache.Wire.$wa4
                           ww1
                           Database.Memcache.Protocol.quit6
                           s1 of ds1 { (#,#) ipv ipv1 ->
                    case ww1
                           `cast`
                         (Foreign.C.Types.NTCo:CInt[0]) of ww6 { GHC.Int.I32# ww7 ->
                    case Foreign.C.Error.throwErrnoIfMinus1Retry2
                           @ Foreign.C.Types.CInt
                           Network.Socket.Internal.throwSocketErrorIfMinus1Retry2
                           Network.Socket.shutdown2
                           (\ eta1 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                            case {__pkg_ccall network-2.6.2.1@netwo_A6pE0dLgMEk2GtUa1JtTJQ shutdown GHC.Prim.Int#
                                                                                                    -> GHC.Prim.Int#
                                                                                                    -> GHC.Prim.State#
                                                                                                         GHC.Prim.RealWorld
                                                                                                    -> (# GHC.Prim.State#
                                                                                                            GHC.Prim.RealWorld,
                                                                                                          GHC.Prim.Int# #)}
                                   ww7
                                   1
                                   eta1 of wild1 { (#,#) ds ds2 ->
                            (# ds, GHC.Int.I32# (GHC.Prim.narrow32Int# ds2) #) })
                             `cast`
                           (Sym (GHC.Types.NTCo:IO[0] (Foreign.C.Types.NTCo:CInt[0])))
                           ipv of ds2 { (#,#) ipv2 ipv3 ->
                    case Database.Memcache.Wire.recv1
                           ww
                           ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                    case Database.Memcache.Types.$fEqIncorrectResponse_$c==
                           (Database.Memcache.Types.resOp ipv5)
                           Database.Memcache.Protocol.quit5 of wild {
                      GHC.Types.False
                      -> GHC.Prim.raiseIO#
                           @ GHC.Exception.SomeException
                           @ ()
                           (Database.Memcache.Types.$fExceptionIncorrectResponse_$ctoException
                              (Database.Memcache.Types.IncorrectResponse
                                 (GHC.CString.unpackAppendCString#
                                    "Expected "#
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       Database.Memcache.Protocol.quit4
                                       (GHC.CString.unpackAppendCString#
                                          " response! Got: "#
                                          (case ipv5 of wild1 { Database.Memcache.Types.Res ds4 ds5 ds6 ds7 ->
                                           Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                                             GHC.Show.shows18
                                             ds4
                                             (GHC.Types.[] @ GHC.Types.Char) }))))
                                 ipv5))
                           ipv4
                      GHC.Types.True
                      -> case ipv5 of wild1 { Database.Memcache.Types.Res ds4 ds5 ds6 ds7 ->
                         case ds5 of wild2 {
                           DEFAULT
                           -> GHC.Prim.raiseIO#
                                @ GHC.Exception.SomeException
                                @ ()
                                (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                   (case wild2 of wild3 {
                                      Database.Memcache.Types.ErrKeyNotFound
                                      -> Database.Memcache.Errors.MemErrNoKey
                                      Database.Memcache.Types.ErrKeyExists
                                      -> Database.Memcache.Errors.MemErrKeyExists
                                      Database.Memcache.Types.ErrValueTooLarge
                                      -> Database.Memcache.Errors.MemErrValueTooLarge
                                      Database.Memcache.Types.ErrInvalidArgs
                                      -> Database.Memcache.Errors.MemErrInvalidArgs
                                      Database.Memcache.Types.ErrItemNotStored
                                      -> Database.Memcache.Errors.MemErrStoreFailed
                                      Database.Memcache.Types.ErrValueNonNumeric
                                      -> Database.Memcache.Errors.MemErrValueNonNumeric
                                      Database.Memcache.Types.ErrUnknownCommand
                                      -> Database.Memcache.Errors.MemErrUnknownCmd
                                      Database.Memcache.Types.ErrOutOfMemory
                                      -> Database.Memcache.Errors.MemErrOutOfMemory
                                      Database.Memcache.Types.SaslAuthFail
                                      -> Database.Memcache.Errors.MemErrAuthFail
                                      Database.Memcache.Types.SaslAuthContinue
                                      -> Database.Memcache.Protocol.add2 }))
                                ipv4
                           Database.Memcache.Types.NoError
                           -> (# ipv4, GHC.Tuple.() #) } } } } } } } })
                   Database.Memcache.Protocol.quit3
                   eta) -}
d9fd5913b984f0f530b62eea54a16856
  quit3 ::
    GHC.Exception.SomeException
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (\ e1 :: GHC.Exception.SomeException[OneShot]
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 (# eta, GHC.Tuple.() #)) -}
a91c00512bc61dc49a74670b6c43c863
  quit4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "QUIT"#) -}
7a025e8a0376b0b7736c521162ead38e
  quit5 :: Database.Memcache.Types.OpResponse
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Database.Memcache.Types.ResQuit
                   Database.Memcache.Types.Loud) -}
9e8018c33dcdd10c6d7e19e8c383c78e
  quit6 :: Database.Memcache.Types.Request
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Database.Memcache.Types.Req
                   Database.Memcache.Protocol.quit7
                   Database.Memcache.Types.emptyReq2
                   Database.Memcache.Types.emptyReq1) -}
e99cfe9f960f399b1eccc6e3a736a516
  quit7 :: Database.Memcache.Types.OpRequest
  {- HasNoCafRefs, Strictness: m16,
     Unfolding: (Database.Memcache.Types.ReqQuit
                   Database.Memcache.Types.Loud) -}
b578e506c0636c6298cb5edef4a7180e
  replace ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Value
    -> Database.Memcache.Types.Flags
    -> Database.Memcache.Types.Expiration
    -> Database.Memcache.Types.Version
    -> GHC.Types.IO (GHC.Base.Maybe Database.Memcache.Types.Version)
  {- Arity: 7,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U><L,U><L,U(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Protocol.replace1
                  `cast`
                (<Database.Memcache.Server.Server>_R
                 ->_R <Database.Memcache.Types.Key>_R
                 ->_R <Database.Memcache.Types.Value>_R
                 ->_R <Database.Memcache.Types.Flags>_R
                 ->_R <Database.Memcache.Types.Expiration>_R
                 ->_R <Database.Memcache.Types.Version>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0]
                               <GHC.Base.Maybe Database.Memcache.Types.Version>_R)) -}
73a1e2a128811043145ec0dd98338555
  replace1 ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Value
    -> Database.Memcache.Types.Flags
    -> Database.Memcache.Types.Expiration
    -> Database.Memcache.Types.Version
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Base.Maybe Database.Memcache.Types.Version #)
  {- Arity: 7,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U><L,U><L,U(U)><L,U>,
     Unfolding: (\ c :: Database.Memcache.Server.Server
                   k :: Database.Memcache.Types.Key
                   v :: Database.Memcache.Types.Value
                   f :: Database.Memcache.Types.Flags
                   e :: Database.Memcache.Types.Expiration
                   ver :: Database.Memcache.Types.Version
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Database.Memcache.Server.sendRecv1
                        c
                        (Database.Memcache.Types.Req
                           (Database.Memcache.Types.ReqReplace
                              Database.Memcache.Types.Loud
                              k
                              v
                              (Database.Memcache.Types.SESet f e))
                           Database.Memcache.Types.emptyReq2
                           ver)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case Database.Memcache.Types.$fEqIncorrectResponse_$c==
                        (Database.Memcache.Types.resOp ipv1)
                        Database.Memcache.Protocol.replace3 of wild {
                   GHC.Types.False
                   -> case GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ ()
                             (Database.Memcache.Types.$fExceptionIncorrectResponse_$ctoException
                                (Database.Memcache.Types.IncorrectResponse
                                   (GHC.CString.unpackAppendCString#
                                      "Expected "#
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         Database.Memcache.Protocol.replace2
                                         (GHC.CString.unpackAppendCString#
                                            " response! Got: "#
                                            (case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                                             Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                                               GHC.Show.shows18
                                               ds2
                                               (GHC.Types.[] @ GHC.Types.Char) }))))
                                   ipv1))
                             ipv
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                GHC.Base.Maybe Database.Memcache.Types.Version #)
                      of {}
                   GHC.Types.True
                   -> case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ (GHC.Base.Maybe Database.Memcache.Types.Version)
                             (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                (case wild2 of wild3 {
                                   Database.Memcache.Types.ErrValueTooLarge
                                   -> Database.Memcache.Errors.MemErrValueTooLarge
                                   Database.Memcache.Types.ErrInvalidArgs
                                   -> Database.Memcache.Errors.MemErrInvalidArgs
                                   Database.Memcache.Types.ErrItemNotStored
                                   -> Database.Memcache.Errors.MemErrStoreFailed
                                   Database.Memcache.Types.ErrValueNonNumeric
                                   -> Database.Memcache.Errors.MemErrValueNonNumeric
                                   Database.Memcache.Types.ErrUnknownCommand
                                   -> Database.Memcache.Errors.MemErrUnknownCmd
                                   Database.Memcache.Types.ErrOutOfMemory
                                   -> Database.Memcache.Errors.MemErrOutOfMemory
                                   Database.Memcache.Types.SaslAuthFail
                                   -> Database.Memcache.Errors.MemErrAuthFail
                                   Database.Memcache.Types.SaslAuthContinue
                                   -> Database.Memcache.Protocol.add2 }))
                             ipv
                        Database.Memcache.Types.NoError
                        -> (# ipv, GHC.Base.Just @ Database.Memcache.Types.Version ds5 #)
                        Database.Memcache.Types.ErrKeyNotFound
                        -> (# ipv, GHC.Base.Nothing @ Database.Memcache.Types.Version #)
                        Database.Memcache.Types.ErrKeyExists
                        -> (# ipv,
                              GHC.Base.Nothing @ Database.Memcache.Types.Version #) } } } }) -}
98568d029f1aec0386a0ed815722d51a
  replace2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "REPLACE"#) -}
ed807f2ecf8c90d9f039efb52eb59912
  replace3 :: Database.Memcache.Types.OpResponse
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Database.Memcache.Types.ResReplace
                   Database.Memcache.Types.Loud) -}
ec87a84c5714e04758e7c568f9b10623
  set ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Value
    -> Database.Memcache.Types.Flags
    -> Database.Memcache.Types.Expiration
    -> GHC.Types.IO Database.Memcache.Types.Version
  {- Arity: 6,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Protocol.set1
                  `cast`
                (<Database.Memcache.Server.Server>_R
                 ->_R <Database.Memcache.Types.Key>_R
                 ->_R <Database.Memcache.Types.Value>_R
                 ->_R <Database.Memcache.Types.Flags>_R
                 ->_R <Database.Memcache.Types.Expiration>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0]
                               <Database.Memcache.Types.Version>_R)) -}
ef813f73a526fc133db303b39067c836
  set' ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Value
    -> Database.Memcache.Types.Flags
    -> Database.Memcache.Types.Expiration
    -> Database.Memcache.Types.Version
    -> GHC.Types.IO (GHC.Base.Maybe Database.Memcache.Types.Version)
  {- Arity: 7,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U><L,U><L,U(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Protocol.set'1
                  `cast`
                (<Database.Memcache.Server.Server>_R
                 ->_R <Database.Memcache.Types.Key>_R
                 ->_R <Database.Memcache.Types.Value>_R
                 ->_R <Database.Memcache.Types.Flags>_R
                 ->_R <Database.Memcache.Types.Expiration>_R
                 ->_R <Database.Memcache.Types.Version>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0]
                               <GHC.Base.Maybe Database.Memcache.Types.Version>_R)) -}
5c830e36d233f307f1e14aefb647c2bf
  set'1 ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Value
    -> Database.Memcache.Types.Flags
    -> Database.Memcache.Types.Expiration
    -> Database.Memcache.Types.Version
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Base.Maybe Database.Memcache.Types.Version #)
  {- Arity: 7,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U><L,U><L,U(U)><L,U>,
     Unfolding: (\ c :: Database.Memcache.Server.Server
                   k :: Database.Memcache.Types.Key
                   v :: Database.Memcache.Types.Value
                   f :: Database.Memcache.Types.Flags
                   e :: Database.Memcache.Types.Expiration
                   ver :: Database.Memcache.Types.Version
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Database.Memcache.Server.sendRecv1
                        c
                        (Database.Memcache.Types.Req
                           (Database.Memcache.Types.ReqSet
                              Database.Memcache.Types.Loud
                              k
                              v
                              (Database.Memcache.Types.SESet f e))
                           Database.Memcache.Types.emptyReq2
                           ver)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case Database.Memcache.Types.$fEqIncorrectResponse_$c==
                        (Database.Memcache.Types.resOp ipv1)
                        Database.Memcache.Protocol.set3 of wild {
                   GHC.Types.False
                   -> case GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ ()
                             (Database.Memcache.Types.$fExceptionIncorrectResponse_$ctoException
                                (Database.Memcache.Types.IncorrectResponse
                                   (GHC.CString.unpackAppendCString#
                                      "Expected "#
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         Database.Memcache.Protocol.set2
                                         (GHC.CString.unpackAppendCString#
                                            " response! Got: "#
                                            (case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                                             Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                                               GHC.Show.shows18
                                               ds2
                                               (GHC.Types.[] @ GHC.Types.Char) }))))
                                   ipv1))
                             ipv
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                GHC.Base.Maybe Database.Memcache.Types.Version #)
                      of {}
                   GHC.Types.True
                   -> case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ (GHC.Base.Maybe Database.Memcache.Types.Version)
                             (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                (case wild2 of wild3 {
                                   Database.Memcache.Types.ErrValueTooLarge
                                   -> Database.Memcache.Errors.MemErrValueTooLarge
                                   Database.Memcache.Types.ErrInvalidArgs
                                   -> Database.Memcache.Errors.MemErrInvalidArgs
                                   Database.Memcache.Types.ErrItemNotStored
                                   -> Database.Memcache.Errors.MemErrStoreFailed
                                   Database.Memcache.Types.ErrValueNonNumeric
                                   -> Database.Memcache.Errors.MemErrValueNonNumeric
                                   Database.Memcache.Types.ErrUnknownCommand
                                   -> Database.Memcache.Errors.MemErrUnknownCmd
                                   Database.Memcache.Types.ErrOutOfMemory
                                   -> Database.Memcache.Errors.MemErrOutOfMemory
                                   Database.Memcache.Types.SaslAuthFail
                                   -> Database.Memcache.Errors.MemErrAuthFail
                                   Database.Memcache.Types.SaslAuthContinue
                                   -> Database.Memcache.Protocol.add2 }))
                             ipv
                        Database.Memcache.Types.NoError
                        -> (# ipv, GHC.Base.Just @ Database.Memcache.Types.Version ds5 #)
                        Database.Memcache.Types.ErrKeyNotFound
                        -> (# ipv, GHC.Base.Nothing @ Database.Memcache.Types.Version #)
                        Database.Memcache.Types.ErrKeyExists
                        -> (# ipv,
                              GHC.Base.Nothing @ Database.Memcache.Types.Version #) } } } }) -}
34d35c342f6ce89c64846b23b82f6511
  set1 ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Value
    -> Database.Memcache.Types.Flags
    -> Database.Memcache.Types.Expiration
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Database.Memcache.Types.Version #)
  {- Arity: 6,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U><L,U><L,U>,
     Unfolding: (\ c :: Database.Memcache.Server.Server
                   k :: Database.Memcache.Types.Key
                   v :: Database.Memcache.Types.Value
                   f :: Database.Memcache.Types.Flags
                   e :: Database.Memcache.Types.Expiration
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Database.Memcache.Server.sendRecv1
                        c
                        (Database.Memcache.Types.Req
                           (Database.Memcache.Types.ReqSet
                              Database.Memcache.Types.Loud
                              k
                              v
                              (Database.Memcache.Types.SESet f e))
                           Database.Memcache.Types.emptyReq2
                           Database.Memcache.Types.emptyReq1)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case Database.Memcache.Types.$fEqIncorrectResponse_$c==
                        (Database.Memcache.Types.resOp ipv1)
                        Database.Memcache.Protocol.set3 of wild {
                   GHC.Types.False
                   -> case GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ ()
                             (Database.Memcache.Types.$fExceptionIncorrectResponse_$ctoException
                                (Database.Memcache.Types.IncorrectResponse
                                   (GHC.CString.unpackAppendCString#
                                      "Expected "#
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         Database.Memcache.Protocol.set2
                                         (GHC.CString.unpackAppendCString#
                                            " response! Got: "#
                                            (case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                                             Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                                               GHC.Show.shows18
                                               ds2
                                               (GHC.Types.[] @ GHC.Types.Char) }))))
                                   ipv1))
                             ipv
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                Database.Memcache.Types.Version #)
                      of {}
                   GHC.Types.True
                   -> case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ Database.Memcache.Types.Version
                             (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                (case wild2 of wild3 {
                                   Database.Memcache.Types.ErrKeyNotFound
                                   -> Database.Memcache.Errors.MemErrNoKey
                                   Database.Memcache.Types.ErrKeyExists
                                   -> Database.Memcache.Errors.MemErrKeyExists
                                   Database.Memcache.Types.ErrValueTooLarge
                                   -> Database.Memcache.Errors.MemErrValueTooLarge
                                   Database.Memcache.Types.ErrInvalidArgs
                                   -> Database.Memcache.Errors.MemErrInvalidArgs
                                   Database.Memcache.Types.ErrItemNotStored
                                   -> Database.Memcache.Errors.MemErrStoreFailed
                                   Database.Memcache.Types.ErrValueNonNumeric
                                   -> Database.Memcache.Errors.MemErrValueNonNumeric
                                   Database.Memcache.Types.ErrUnknownCommand
                                   -> Database.Memcache.Errors.MemErrUnknownCmd
                                   Database.Memcache.Types.ErrOutOfMemory
                                   -> Database.Memcache.Errors.MemErrOutOfMemory
                                   Database.Memcache.Types.SaslAuthFail
                                   -> Database.Memcache.Errors.MemErrAuthFail
                                   Database.Memcache.Types.SaslAuthContinue
                                   -> Database.Memcache.Protocol.add2 }))
                             ipv
                        Database.Memcache.Types.NoError -> (# ipv, ds5 #) } } } }) -}
f4a44bb240d83555cb78e0f6e2b6ea6f
  set2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SET"#) -}
65aa284e62581051f99ee0b7bf4e0318
  set3 :: Database.Memcache.Types.OpResponse
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (Database.Memcache.Types.ResSet
                   Database.Memcache.Types.Loud) -}
c0f559e72443d268c7b649042fa06a29
  stats ::
    Database.Memcache.Server.Server
    -> GHC.Base.Maybe Database.Memcache.Types.Key
    -> GHC.Types.IO
         (GHC.Base.Maybe Database.Memcache.Protocol.StatResults)
  {- Arity: 3,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Protocol.stats1
                  `cast`
                (<Database.Memcache.Server.Server>_R
                 ->_R <GHC.Base.Maybe Database.Memcache.Types.Key>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0]
                               <GHC.Base.Maybe
                                  [(Database.Memcache.Types.Key,
                                    Database.Memcache.Types.Value)]>_R)) -}
1be0a52f420dc34a66ae57a105390583
  stats1 ::
    Database.Memcache.Server.Server
    -> GHC.Base.Maybe Database.Memcache.Types.Key
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Base.Maybe
            [(Database.Memcache.Types.Key, Database.Memcache.Types.Value)] #)
  {- Arity: 3,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U>,
     Unfolding: (\ c :: Database.Memcache.Server.Server
                   key :: GHC.Base.Maybe Database.Memcache.Types.Key
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 Data.Pool.withResource1
                   @ Network.Socket.Types.Socket
                   @ (GHC.Base.Maybe
                        [(Database.Memcache.Types.Key, Database.Memcache.Types.Value)])
                   (case c of wild { Database.Memcache.Server.Server dt ds ds1 dt1 ds2 ds3 ->
                    ds })
                   (\ s :: Network.Socket.Types.Socket[OneShot]
                      eta1 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                    case s of ww { Network.Socket.Types.MkSocket ww1 ww2 ww3 ww4 ww5 ->
                    case Database.Memcache.Wire.$wa4
                           ww1
                           (Database.Memcache.Types.Req
                              (Database.Memcache.Types.ReqStat key)
                              Database.Memcache.Types.emptyReq2
                              Database.Memcache.Types.emptyReq1)
                           eta1 of ds1 { (#,#) ipv ipv1 ->
                    Database.Memcache.Protocol.stats2
                      ww
                      (GHC.Types.[]
                         @ (Database.Memcache.Types.Key, Database.Memcache.Types.Value))
                      ipv } })
                     `cast`
                   (<Network.Socket.Types.Socket>_R
                    ->_R Sym (GHC.Types.NTCo:IO[0]
                                  <GHC.Base.Maybe
                                     [(Database.Memcache.Types.Key,
                                       Database.Memcache.Types.Value)]>_R))
                   eta) -}
191a83ae2f02352093e22954cdc778fa
  stats2 ::
    Network.Socket.Types.Socket
    -> [(Database.Memcache.Types.Key, Database.Memcache.Types.Value)]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Base.Maybe
            [(Database.Memcache.Types.Key, Database.Memcache.Types.Value)] #)
  {- Arity: 3, Strictness: <L,U(U(U),A,A,A,A)><L,U><L,U> -}
9bb9dcde010d4b8fec3a45abb0b63009
  touch ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Expiration
    -> GHC.Types.IO (GHC.Base.Maybe Database.Memcache.Types.Version)
  {- Arity: 4,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Protocol.touch1
                  `cast`
                (<Database.Memcache.Server.Server>_R
                 ->_R <Database.Memcache.Types.Key>_R
                 ->_R <Database.Memcache.Types.Expiration>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0]
                               <GHC.Base.Maybe Database.Memcache.Types.Version>_R)) -}
464e7709bcd4bdaf3a8566bb558a59c7
  touch1 ::
    Database.Memcache.Server.Server
    -> Database.Memcache.Types.Key
    -> Database.Memcache.Types.Expiration
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Base.Maybe Database.Memcache.Types.Version #)
  {- Arity: 4,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U><L,U><L,U>,
     Unfolding: (\ c :: Database.Memcache.Server.Server
                   k :: Database.Memcache.Types.Key
                   e :: Database.Memcache.Types.Expiration
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Database.Memcache.Server.sendRecv1
                        c
                        (Database.Memcache.Types.Req
                           (Database.Memcache.Types.ReqTouch
                              k
                              (Database.Memcache.Types.SETouch e))
                           Database.Memcache.Types.emptyReq2
                           Database.Memcache.Types.emptyReq1)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case Database.Memcache.Types.$fEqIncorrectResponse_$c==
                        (Database.Memcache.Types.resOp ipv1)
                        Database.Memcache.Types.ResTouch of wild {
                   GHC.Types.False
                   -> case GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ ()
                             (Database.Memcache.Types.$fExceptionIncorrectResponse_$ctoException
                                (Database.Memcache.Types.IncorrectResponse
                                   (GHC.CString.unpackAppendCString#
                                      "Expected "#
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         Database.Memcache.Protocol.touch2
                                         (GHC.CString.unpackAppendCString#
                                            " response! Got: "#
                                            (case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                                             Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                                               GHC.Show.shows18
                                               ds2
                                               (GHC.Types.[] @ GHC.Types.Char) }))))
                                   ipv1))
                             ipv
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                GHC.Base.Maybe Database.Memcache.Types.Version #)
                      of {}
                   GHC.Types.True
                   -> case ipv1 of wild1 { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ (GHC.Base.Maybe Database.Memcache.Types.Version)
                             (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                (case wild2 of wild3 {
                                   Database.Memcache.Types.ErrKeyExists
                                   -> Database.Memcache.Errors.MemErrKeyExists
                                   Database.Memcache.Types.ErrValueTooLarge
                                   -> Database.Memcache.Errors.MemErrValueTooLarge
                                   Database.Memcache.Types.ErrInvalidArgs
                                   -> Database.Memcache.Errors.MemErrInvalidArgs
                                   Database.Memcache.Types.ErrItemNotStored
                                   -> Database.Memcache.Errors.MemErrStoreFailed
                                   Database.Memcache.Types.ErrValueNonNumeric
                                   -> Database.Memcache.Errors.MemErrValueNonNumeric
                                   Database.Memcache.Types.ErrUnknownCommand
                                   -> Database.Memcache.Errors.MemErrUnknownCmd
                                   Database.Memcache.Types.ErrOutOfMemory
                                   -> Database.Memcache.Errors.MemErrOutOfMemory
                                   Database.Memcache.Types.SaslAuthFail
                                   -> Database.Memcache.Errors.MemErrAuthFail
                                   Database.Memcache.Types.SaslAuthContinue
                                   -> Database.Memcache.Protocol.add2 }))
                             ipv
                        Database.Memcache.Types.NoError
                        -> (# ipv, GHC.Base.Just @ Database.Memcache.Types.Version ds5 #)
                        Database.Memcache.Types.ErrKeyNotFound
                        -> (# ipv,
                              GHC.Base.Nothing @ Database.Memcache.Types.Version #) } } } }) -}
6fe87f30e335f3d79e31ce0fe77e88a5
  touch2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TOUCH"#) -}
9de97ec71daa69ae6e648b0de1da6fff
  version ::
    Database.Memcache.Server.Server
    -> GHC.Types.IO Data.ByteString.Internal.ByteString
  {- Arity: 2,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Database.Memcache.Protocol.version1
                  `cast`
                (<Database.Memcache.Server.Server>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0]
                               <Data.ByteString.Internal.ByteString>_R)) -}
5efa1fd9b2ed78dd3dddb51731490b5a
  version1 ::
    Database.Memcache.Server.Server
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.ByteString.Internal.ByteString #)
  {- Arity: 2,
     Strictness: <L,1*U(A,1*U(C(U),1*C1(C1(U)),1*U(1*U),A,1*U(U),U(U,U,U),A),1*H,A,1*H,1*H)><L,U>,
     Unfolding: (\ c :: Database.Memcache.Server.Server
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Database.Memcache.Server.sendRecv1
                        c
                        Database.Memcache.Protocol.version3
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { Database.Memcache.Types.Res ds2 ds3 ds4 ds5 ->
                 case ds2 of wild1 {
                   DEFAULT
                   -> GHC.Prim.raiseIO#
                        @ GHC.Exception.SomeException
                        @ Database.Memcache.Types.Value
                        (Database.Memcache.Types.$fExceptionIncorrectResponse_$ctoException
                           (Database.Memcache.Types.IncorrectResponse
                              (GHC.CString.unpackAppendCString#
                                 "Expected "#
                                 (GHC.Base.++
                                    @ GHC.Types.Char
                                    Database.Memcache.Protocol.version2
                                    (GHC.CString.unpackAppendCString#
                                       " response! Got: "#
                                       (Database.Memcache.Types.$fExceptionIncorrectResponse_$cshowsPrec1
                                          GHC.Show.shows18
                                          wild1
                                          (GHC.Types.[] @ GHC.Types.Char)))))
                              wild))
                        ipv
                   Database.Memcache.Types.ResVersion v
                   -> case ds3 of wild2 {
                        DEFAULT
                        -> GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ Data.ByteString.Internal.ByteString
                             (Database.Memcache.Errors.$fExceptionMemcacheError_$ctoException
                                (case wild2 of wild3 {
                                   Database.Memcache.Types.ErrKeyNotFound
                                   -> Database.Memcache.Errors.MemErrNoKey
                                   Database.Memcache.Types.ErrKeyExists
                                   -> Database.Memcache.Errors.MemErrKeyExists
                                   Database.Memcache.Types.ErrValueTooLarge
                                   -> Database.Memcache.Errors.MemErrValueTooLarge
                                   Database.Memcache.Types.ErrInvalidArgs
                                   -> Database.Memcache.Errors.MemErrInvalidArgs
                                   Database.Memcache.Types.ErrItemNotStored
                                   -> Database.Memcache.Errors.MemErrStoreFailed
                                   Database.Memcache.Types.ErrValueNonNumeric
                                   -> Database.Memcache.Errors.MemErrValueNonNumeric
                                   Database.Memcache.Types.ErrUnknownCommand
                                   -> Database.Memcache.Errors.MemErrUnknownCmd
                                   Database.Memcache.Types.ErrOutOfMemory
                                   -> Database.Memcache.Errors.MemErrOutOfMemory
                                   Database.Memcache.Types.SaslAuthFail
                                   -> Database.Memcache.Errors.MemErrAuthFail
                                   Database.Memcache.Types.SaslAuthContinue
                                   -> Database.Memcache.Protocol.add2 }))
                             ipv
                        Database.Memcache.Types.NoError -> (# ipv, v #) } } } }) -}
c2373c0dcbbd06b81a44826a107b4a92
  version2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VERSION"#) -}
968c2cdc1565205f0cb9056a650a16c0
  version3 :: Database.Memcache.Types.Request
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Database.Memcache.Types.Req
                   Database.Memcache.Types.ReqVersion
                   Database.Memcache.Types.emptyReq2
                   Database.Memcache.Types.emptyReq1) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

